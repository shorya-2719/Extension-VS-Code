directive @connection(key: String!, filter: [String!]) on FIELD
directive @client(always: Boolean) on FIELD

# Directive to make OAM aware of the query / mutation
# Docs at: docs/dev-designs/Offline-Actions-Manager/offline-actions-manager.md
directive @offlineAction(
  preferredActionId: String
  parentActionId: String
  queueId: String
  shouldExecute: Boolean
  maxCrossSessionRetries: Int
  dependentActionQueueId: String
  expirationInMs: Int
  ignoreQueueOnFirstExecution: Boolean
) on FIELD_DEFINITION | FIELD | MUTATION

# Assign a model to a type.
#
# ```
# type Foo @model(from: "@msteams/data-resolver-types", tsType: "FooModel", scope: SERVER_RESOLVERS) {
#
# }
# ```
#
# The model will be used instead of this type in return types of resolvers and parent types
# of field resolvers.
#
# You should specify SERVER_RESOLVERS, BROWSER_RESOLVERS or CLIENT_RESOLVERS as scope of model to indicate
# the execution context where this applies

directive @model(
  from: String
  tsType: String!
  scope: ModelDirectiveScope!
) repeatable on OBJECT | SCALAR

enum ModelDirectiveScope {
  SERVER_RESOLVERS
  BROWSER_RESOLVERS
  CLIENT_RESOLVERS
}

# Import a type and model from a different package.
#
# NB: Currently unused in TMP because we operate on one module.
#
# ```
# extend schema @import(from: "@msteams/data-resolvers-user", defs: ["User"])
# ```

directive @import(from: String!, defs: [String!]!) repeatable on SCHEMA

# Opt-out into new empty interface generation. Generates full interface type like in legacy codegen.
#
# We don't want to use interface types in our code - interfaces don't actually exist in GraphQL. A better
# way is always to use Union types and use interfaces only for fragment sharing inside GraphQL. For
# cases where you have common utilities that share data you should define an interface on that shared
# data yourself - but generally avoid that and just use unions to operate on a fixed set of types.

directive @legacyInterface_DO_NOT_USE on INTERFACE

enum DisplayWaterMark {
  On
  Off
  Fade
}

type CommunityNotificationSettings {
  id: ID!
  inviteOnNetworkEmailOptIn: Boolean
  announcementEmailOptIn: Boolean
}

type HardwareOutDevice {
  id: ID!
  description: String!
  isAvailable: Boolean!
  callId: ID
  participantId: ID
  localStream: Boolean
  participantStreamId: Int
  videoType: StreamType
  format: String
  formats: [String]
  participantDisplayName: String
}

"""
enum is from https://skype.visualstudio.com/SCC/_git/client-shared_calling_ts-calling?path=%2Fskype-calling-interface%2Fskype-calling-interface.d.ts&version=GBmaster&line=3040&lineEnd=3040&lineStartColumn=19&lineEndColumn=36&lineStyle=plain&_a=contents
"""
enum PtzControlCommand {
  Reset
  ZoomIn
  ZoomOut
  PanLeft
  PanRight
  TiltUp
  TiltDown
}

enum TranscriptEditType {
  Speaker
}

enum TranscriptDownloadFormat {
  Vtt
  Docx
  Pdf
}

input DriveRecipientInput {
  email: String
  alias: String
  objectId: String
}

enum LinkScopeInput {
  anonymous
  organization
  users
  existingAccess
}

enum LinkTypeInput {
  view
  edit
}

input CreateShareLinkOptions {
  deferRedeemEnabled: Boolean!
  partialSuccessEnabled: Boolean!
}

input PptSharingContentInput {
  id: ID!
  name: String!
  type: ShareableContentType!
  source: PptSharingSource!
  exchangeMeta: ExchangeContentMetaInput
  icon: String
  url: String
  siteUrl: String
  appName: String
  """
  This shareUrl being added here only for whiteboard sharing.
  Currently the excel, word content sharing is using PptSharingContentInput and in the future this will be merged to be officeSharingContentInput which can be shared by all office extensible apps.
  """
  shareUrl: String
}

enum MediaEventType {
  MediaPaused
  MediaPlayed
  MediaStopped
  MediaSeeked
  MediaVolumeChanged
}

input ExchangeContentMetaInput {
  type: String!
  eventId: String!
}

input AcceptOptions {
  withVideo: Boolean
  muted: Boolean
}

enum TeamLayoutPreferenceOptions {
  list
  grid
}

type MuteNotificationsResponse {
  teamsCallId: ID
  isNotificationMuted: Boolean!
}

input CalendarEventsFilterInput {
  key: String!
  value: String!
}

input MailboxAddressInput {
  mailboxAddress: String!
  threadId: String
  type: String
  color: String
}

input SchedulingServiceEventInput {
  startTime: DateTime
  endTime: DateTime
  subject: String
  groupContext: SchedulingServiceChatContextInput!
  etag: String!
  meetingUrl: String!
  links: SchedulingServiceMeetingLinksInput!
  views: SchedulingServiceMeetingViewsInput!
  onlineMeetingConfLink: String
  onlineMeetingConferenceId: String
  onlineMeetingTollFreeNumbers: [String]
  onlineMeetingTollNumber: String
  teamsVtcTenantId: String
  teamsVtcConferenceId: String
  meetingTemplateId: String
}

input SchedulingServiceEventUpdateInput {
  """
  subject of the SS event
  """
  subject: String!
  """
  start time of the SS event
  """
  startTime: DateTime!
  """
  end time of the SS event
  """
  endTime: DateTime!
  """
  meeting url to be used for get/update/delete
  """
  meetingUrl: String!
}

"""
Deprecated use ClosedCaptionsStatusEvent
"""
type ClosedCaptionStateChanged {
  participant: Participant
  callClosedCaptionState: CallClosedCaptionStatus!
}

type PtzParticipant {
  id: ID!
  displayName: String
  active: Boolean
}

type PtzCapableParticipants {
  participants: [PtzParticipant!]
}

union ContentSharingSession = PptSharingSession | WhiteboardSharingSession

type ContentSharingAdded {
  teamsCallId: ID!
  contentSharingSession: ContentSharingSession!
}

enum SystemAudioSupport {
  NotSupported
  Unavailable
  Available
}

type PrejoinInitState {
  callingReady: Boolean!
  devicesReady: Boolean!
}

type EmergencyPhoneNumberResult {
  phoneNumber: String
  encodedContent: String
}

"""
AddressInput and Address should always match.
"""
input AddressInput {
  companyName: String
  streetName: String
  streetSuffix: String
  additionalInfo: String
  houseNumber: String
  houseNumberSuffix: String
  postDirectional: String
  preDirectional: String
  cityOrTown: String
  countyOrDistrict: String
  stateOrProvince: String
  country: String
  postalOrZipCode: String
}

type Address {
  companyName: String
  streetName: String
  streetSuffix: String
  additionalInfo: String
  houseNumber: String
  houseNumberSuffix: String
  postDirectional: String
  preDirectional: String
  cityOrTown: String
  countyOrDistrict: String
  stateOrProvince: String
  country: String
  postalOrZipCode: String
}

type Geocoordinates {
  latitude: Float!
  longitude: Float!
}

input GeocoordinatesInput {
  latitude: Float!
  longitude: Float!
}

enum EmergencyLocationType {
  LIS
  CLS
  Assist
  Manual
  Registered
  None
}

type EmergencyAddressResult {
  address: Address
  type: EmergencyLocationType!
  editable: Boolean!
  geocoordinates: Geocoordinates
}

input EmergencyAddressResultInput {
  address: AddressInput
  type: EmergencyLocationType!
  editable: Boolean!
  geocoordinates: GeocoordinatesInput
}

type SendMessageActionData {
  convId: ID!
  replyChainId: String
  message: Message
}

type ReactionsActionData {
  convId: ID!
  replyChainId: String
  message: Message
}

type ErrorActionData {
  status: String
  errorMessage: String
  errorCode: Int
  code: Int
  errorSubCode: Int
}

union ActionStatusEvent =
    SendMessageActionData
  | ReactionsActionData
  | ErrorActionData

type PtzRemoteParticipantsChanged {
  participants: [PtzParticipant!]
}

type PtzHandlerFailed {
  ptzHandlerError: PtzErrorReason
}

type PtzRemoteControlDeviceStateChanged {
  deviceState: PtzControlDeviceState
}

type PtzSessionStatusChanged {
  sessionStatus: PtzSessionStatus
}

"""
Below Ptz related enums correlates to https://skype.visualstudio.com/SCC/_git/client-shared_calling_ts-calling?path=%2Fskype-calling-interface%2Fskype-calling-interface.d.ts&version=GBmaster&line=3050&lineEnd=3050&lineStartColumn=19&lineEndColumn=40&lineStyle=plain&_a=contents
"""
type PtzControlDeviceState {
  available: Boolean
  error: Boolean
  reset: Boolean
  zoomIn: Boolean
  zoomOut: Boolean
  panLeft: Boolean
  panRight: Boolean
  tiltUp: Boolean
  tiltDown: Boolean
}

enum PtzErrorReason {
  CommandResetError
  CommandZoomInError
  CommandZoomOutError
  CommandPanLeftError
  CommandPanRightError
  CommandTiltUpError
  CommandTiltDownError
  SendDataError
}

type PtzSessionStatus {
  inControl: Boolean
  terminatedReason: PtzSessionTerminatedReason!
}

enum PtzSessionTerminatedReason {
  None
  ControlDenied
  ControlNoResponse
  ControlBusy
  AckTimeout
  ControlTerminated
  ControllerTerminated
  DataChannelError
  ControllerCancelled
  ControlDisabled
  ControlTerminatedToAllowOtherController
}

input UserFeatureSettingsInfoInput {
  isPrivateChatEnabled: Boolean
  coExistenceMode: String
}

input UserSkypeTeamsInfoInput {
  isSkypeTeamsUser: Boolean
}

input UserFullInput {
  """
  AAD Object ID. Some Users (e.g., bots and PSTN callers) may not have associated AAD object,
  thus this field is nullable.
  """
  objectId: ID
  """
  Thus far, every user has associated Skype MRI. Still, consuming code should be
  prepared to see `null` if things change in future.
  """
  mri: ID
  displayName: String
  email: String
  givenName: String
  isShortProfile: Boolean
  surname: String
  type: String
  userPrincipalName: String
  department: String
  tenantId: String
  featureSettings: UserFeatureSettingsInfoInput
  isSipDisabled: Boolean
  jobTitle: String
  mail: String
  mobile: String
  phones: [PhoneInput!]
  physicalDeliveryOfficeName: String
  sipProxyAddress: String
  skypeTeamsInfo: UserSkypeTeamsInfoInput
  smtpAddresses: [String!]
  telephoneNumber: String
  userLocation: String
  imageUri: String
  accountEnabled: Boolean
  description: String
  isTenantAdmin: Boolean
  privacyStatement: String
  recentActivity: String
  termsOfService: String
  userClassification: String
  userType: String
  isUnified: Boolean
  securityEnabled: Boolean
  isFederated: Boolean
  fetchErrorCode: String
  isAnonymousB2bUser: Boolean
  isBlocked: Boolean
  cid: String
  phonesInfo: [UserPhonesInfoInput]
  emailsInfo: [UserEmailsInfoInput]
  xtapUser: Boolean
  companyName: String
  tenantName: String
  """
  Indicates if the information barrier is enabled for the user.
  This is mapped to the ibBarred field in the user object
  """
  isInfoBarrierSet: Boolean
}

input UserInputCSA {
  accountEnabled: Boolean
  displayName: String
  email: String
  givenName: String
  isEnabled: Boolean
  mri: ID!
  objectId: ID
  surname: String
  type: String
  userPrincipalName: String
  userType: String
  tenantId: String
}

input UserInputFull {
  accountEnabled: Boolean
  department: String
  displayName: String
  email: String
  featureSettings: UserFeatureSettingsInfoInput
  givenName: String
  isShortProfile: Boolean
  isSipDisabled: Boolean
  jobTitle: String
  mail: String
  managerLevel: Int
  mobile: String
  mri: ID!
  objectId: String
  objectType: String
  physicalDeliveryOfficeName: String
  sipProxyAddress: String
  smtpAddresses: [String!]
  telephoneNumber: String
  type: String
  userClassification: String
  userLocation: String
  userPrincipalName: String
  userType: String
  isSelf: Boolean
  isSkypeTeamsUser: Boolean
  imageUri: String
  description: String
  isTenantAdmin: Boolean
  privacyStatement: String
  recentActivity: String
  termsOfService: String
  surname: String
  skypeTeamsInfo: UserSkypeTeamsInfoInput
}

type TypedCalendarEvent {
  event: CalendarEvent
}

input PhoneInput {
  number: String!
  type: PhoneType!
}

input UserPhonesInfoInput {
  number: String
  country: String
  nationalNumber: String
  searchable: Boolean
  visibility: String
}

input UserEmailsInfoInput {
  address: String
  searchable: Boolean
  visibility: String
}

type SchedulingServiceFilteredEvents {
  inDayEvents: [InDayEvents!]
}

type StreamMetadataWithConfig {
  bufferName: String
  isNativeRendering: Boolean
  isNativeRendererCapable: Boolean
}

type OtherDetails {
  localeFromOS: String
  navId: String
  templateId: String
  authApiSecret: String
}

type FileOpenDiagnostics {
  driveItemCallStartTime: Float
  driveItemCallEndTime: Float
  sessionOrigin: String
  userClickTime: Float
}

type FileOpenButtons {
  id: String!
  visibility: Int!
}

type FileMetadata {
  userId: String!
  downloadUrl: String
  fileName: String!
  fileSize: Float!
  accessToken: String!
  accessTokenTtl: Float!
  wopiSrc: String!
  applicationUrl: String!
  bootstrapperUrl: String!
  webUrl: String
  webDavUrl: String
  officeBundleUrl: String
  officeBundleVersion: String
  eTag: String
  id: String
  readOnly: Boolean
  irmEnabled: Boolean
  clientThrottlingProtection: String
  requestedCallThrottling: String
  shareUrl: String
  fileGetUrl: String
  customFontCatalogUrl: String
}

type ListMetadata {
  callerStack: String!
  driveAccessToken: String!
  driveAccessTokenV21: String!
  fileType: String!
  mediaBaseUrl: String!
  spItemUrl: String!
  thumbnailUrl: String!
  transformUrl: String!
}

type FileTransformOutput {
  value: String!
}

type FileOpenInitParams {
  fileMetadata: FileMetadata!
  fileActions: [FileOpenButtons!]
  diagnostics: FileOpenDiagnostics
  otherDetails: OtherDetails
  flights: FileFlights
  rebootOverrideData: String
}

type FileFlights {
  enableWACAppCreateNewDocumentScenario: Boolean
  enableWACAppDocRebootScenario: Boolean
  enableWordRibboninReadMode: Boolean
  enableWACCopyLinkScenario: Boolean
  enableWACAppModeSwitch: Boolean
  enablePassingDynamicThrottlingSignalToWAC: Boolean
  hideWACOneDriveFileLocationPicker: Boolean
  enableFileOpenExperiment: Boolean
  enableWebAsDefaultFileOpenPreference: Boolean
  enableWACUserAccessScenario: Boolean
  enableWACFileRenameScenario: Boolean
  enableExternalLinkScenario: Boolean
  enableWACFilesExperienceSSO: Boolean
  enableOfficeFileOpenWithFileGetUrl: Boolean
  enableFilesUnifiedAppCustomFonts: Boolean
  enableFilesRemoveObsoleteOfficeSessionContextParams: Boolean
  enableFilesOfficeTokenRefresh: Boolean
}

enum CallCoachStatus {
  None
  Disabled
  Pending
  Waiting
  Started
  Stopped
  Failed
}

"""
Depricated use CallClosedCaptionsStatus
"""
enum CallClosedCaptionStatus {
  None
  Started
  Stopped
  Pending
  Failed
  Disabled
}

type CoachResult {
  id: ID!
  timestamp: Int
  userId: ID!
  type: String!
  message: String!
}

enum VideoEffect {
  Off
  BackgroundBlur
  BackgroundReplace
  AutoAdjust
  TouchUp
  EyeContact
  WhiteboardZoom
  WhiteboardCleanup
  WhiteboardZoomAndCleanup
  Greenscreen
}

enum VideoEffectStateType {
  Unavailable
  Off
  Loading
  On
  Error
  NotReady
  ModelNotReady
}

input FileTransformInput {
  callerStack: String!
  driveAccessToken: String!
  fileType: String!
  mediaBaseUrl: String!
  method: String!
  options: Int
  spItemUrl: String!
  transformUrl: String!
}

type CoachStatusEvent {
  teamsCallId: ID
  coachStatus: CallCoachStatus!
  userTurnedOnCoach: Boolean
}

type CallScreenViewOptions {
  showChatPane: Boolean
  showShareTray: Boolean
  showTransferDialog: Boolean
}

enum ArtifactType {
  ImplicitActionItems
  ManualActionItems
}

enum ActionItemsModelInsightType {
  ImplicitActionItem
  ExplicitActionItem
}

enum ActionItemConfidence {
  Low
  High
}

enum ActionItemOwnershipType {
  Unassigned
  Commitment
  Request
  Delegation
}

"""
NOTE: whenever this structure is updated, we MUST update type ActionItemUtteranceInput as well
"""
type ActionItemUtterance {
  createdBy: User!
  content: String!
  createdDateTimeUtc: DateTime!
  transcriptConfidence: Float!
  displayCleanContent: String
  utteranceIndex: Int
}

"""
NOTE: whenever this structure is updated, we MUST update type IndicesInput as well
"""
type Indices {
  """
  The start index of action item within its utterance.
  """
  offset: Int
  """
  The length (number of characters) of the action item within its utterance.
  """
  length: Int
}

"""
NOTE: whenever this structure is updated, we MUST update type ActionItemOwnerInput as well
"""
type ActionItemOwner {
  user: User!
  ownershipType: ActionItemOwnershipType!
}

"""
NOTE: whenever this structure is updated, we MUST update input ActionItemInput as well
"""
type ActionItem {
  id: ID!
  callId: String
  artifactType: ArtifactType!
  score: Float!
  confidenceLevel: ActionItemConfidence!
  mainUtterance: ActionItemUtterance!
  backwardUtterances: [ActionItemUtterance]!
  forwardUtterances: [ActionItemUtterance]!
  assignedTo: ActionItemOwner
  dueDateTimeUtc: DateTime
  """
  The positioning of the action item phrase within the main utterance.
  """
  indices: Indices
  """
  The positioning of the action item phrase within the display text in the main utterance.
  """
  displayCleanIndices: Indices
  insightType: ActionItemsModelInsightType!
  createdDateTimeUtc: DateTime!
  lastModifiedDateTimeUtc: DateTime!
  schemaVersion: String!
}

type ActionItemUpdateResponse {
  isUpdated: Boolean
  updatedActionItem: ActionItem
}

"""
NOTE: whenever this structure is updated, we MUST update type ActionItemUtterance as well
"""
input ActionItemUtteranceInput {
  createdBy: UserFullInput!
  content: String!
  createdDateTimeUtc: DateTime!
  transcriptConfidence: Float!
  displayCleanContent: String
  utteranceIndex: Int
}

"""
NOTE: whenever this structure is updated, we MUST update type Indices as well
"""
input IndicesInput {
  """
  The start index of action item within its utterance.
  """
  offset: Int
  """
  The length (number of characters) of the action item within its utterance.
  """
  length: Int
}

"""
NOTE: whenever this structure is updated, we MUST update type ActionItemOwner as well
"""
input ActionItemOwnerInput {
  user: UserFullInput!
  ownershipType: ActionItemOwnershipType!
}

"""
This structure is almost identical to type ActionItem
NOTE: whenever this structure is updated, we MUST update type ActionItem as well
"""
input ActionItemInput {
  id: ID!
  callId: String
  artifactType: ArtifactType!
  score: Float!
  confidenceLevel: ActionItemConfidence!
  mainUtterance: ActionItemUtteranceInput!
  backwardUtterances: [ActionItemUtteranceInput]!
  forwardUtterances: [ActionItemUtteranceInput]!
  assignedTo: ActionItemOwnerInput
  dueDateTimeUtc: DateTime
  """
  The positioning of the action item phrase within the main utterance.
  """
  indices: IndicesInput
  """
  The positioning of the action item phrase within the display text in the main utterance.
  """
  displayCleanIndices: IndicesInput
  insightType: ActionItemsModelInsightType!
  createdDateTimeUtc: DateTime!
  lastModifiedDateTimeUtc: DateTime!
  schemaVersion: String!
}

type RaiseHandState {
  participantId: ID!
  displayName: String
  isHandRaised: Boolean!
  raiseHandRank: Int
  raiseHandSkinTone: Int
}

scalar DateTime
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

scalar ScalarEnumString
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

scalar BigInt
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

scalar JSONData
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

# The `DateTimeOffset` scalar type represents a date, time and offset from UTC.
# `DateTimeOffset` expects timestamps to be formatted in accordance with the
# [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard.
scalar DateTimeOffset
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

enum TranslationStatusV2 {
  """
  Commonly used non error status for both on-demand and automatic translation
  """
  Done
  InProcess
  NotStarted
  """
  Commonly used error status for both on-demand and automatic translation
  """
  ScoreTooLow
  TooManyCharacters
  UnknownError
  """
  Non error status only used for automatic translation
  """
  TranslationNotNeeded
  ShowOriginalMessage
  """
  Error status only used for automatic translation
  """
  MessageNotFound
  VersionNotFound
  LanguageDetectionFailed
  UnsupportedSourceLanguage
  ClientMutationThrottled
}

enum TranslationStatus {
  Done
  InProcess
  UnknownError
  ScoreTooLow
  TooManyCharacters
  NotStarted
}

type Translation {
  status: TranslationStatus
  content: String
  subject: String
  title: String
  fromLanguage: String
  isChat: Boolean
}

enum CardCacheOperationType {
  GetByKey
  Put
  Delete
  DeleteCardData
  GetAuthBlockLastUsage
  PutAuthBlockLastUsage
}

type CardCacheOperationResponse {
  createdOn: BigInt
  version: String
  data: String
  authBlockLastUsedOn: BigInt
}

input PeoplePickerFiltersInput {
  name: String
  includeFeatures: [String!]
  includeAADTenant: Boolean
  includeGuest: Boolean
  includeFederated: Boolean
  includeFederatedConsumer: Boolean
  includeBot: Boolean
  includeDisabledUser: Boolean
  includeDL: Boolean
  includeModernGroup: Boolean
  includePersonalContact: Boolean
  includeUserDefinedGroup: Boolean
  includePstn: Boolean
  includeCallQandAA: Boolean
  includeRoom: Boolean
  includeTeamTags: Boolean
  includeGroupChats: Boolean
  includeMeetingChats: Boolean
  includeXtap: Boolean
  includeOffNetworkEmails: Boolean
  includeOffNetworkPhones: Boolean
  includeTflConsumer: Boolean
  includeTflSmsName: Boolean
  includeEXOContact: Boolean
  includeImplicitContacts: Boolean
  includeExtendedDirectoryUsers: Boolean
  includeMTOUsers: Boolean
  includeB2BMembers: Boolean
  includeTfl2WaySmsUsers: Boolean
}

type SearchReplyChain {
  parentMessage: Message
  nextMessage: Message
  previousMessage: Message
  currentMessage: Message
  totalCount: Int
  members: [User]
  replyParticipants: [String!]
}

type ExtendedCallType {
  isOneToOnePstn: Boolean!
  isScreenshareFromChat: Boolean!
  isFederated: Boolean!
  isInterop: Boolean!
  isVoicemailGreeting: Boolean
  isEchoBotCall: Boolean
  isContentOnlyMode: Boolean
  isSkypeForConsumerCall: Boolean
  isEmergencyCall: Boolean
  isConsultCall: Boolean
  isMeetingTransferred: Boolean
  isHolographicCall: Boolean
  isVideoTeleConferencingCall: Boolean
}

enum ScreenSharingControlStateAsViewer {
  NotControlCapable
  Disabled
  NotInControl
  RequestSent
  InControl
}

"""
Enumeration of possible sharing source type.
Keep aligned with the content of skype-calling-interface and converter in msteams-cdl.
"""
enum SharingSourceType {
  Monitor
  Window
  Camera
}

type Rectangle {
  x: Int!
  y: Int!
  width: Int!
  height: Int!
}

input GeometryPointInput {
  x: Int!
  y: Int!
}

input GeometrySizeInput {
  width: Int!
  height: Int!
}

type Call {
  """
  id is same as teamsCallId
  """
  id: ID!
  callId: ID!
  participantId: String
  endpointId: String
  tenantId: String
  callType: Int
  callMode: Int
  state: Int!
  extendedCallState: Int!
  isMuted: Boolean!
  isServerMuted: Boolean!
  isExternal: Boolean
  isSpeakerMuted: Boolean
  isCallParked: Boolean
  isMergeable: Boolean
  isVideoOn: Boolean!
  isScreenSharingOn: Boolean!
  isSharingMuted: Boolean
  sharedMonitorRect: Rectangle
  sharingSourceType: SharingSourceType
  sharingLayoutMode: SharingLayoutMode
  isWhiteboardVideoEffectOn: Boolean
  isScdAvailable: Boolean
  isScdEnabled: Boolean
  isPSTNEnabled: Boolean
  isReconciled: Boolean
  isHandRaised: Boolean
  selfRaiseHandsRank: Int
  isSpotlighted: Boolean
  isSpotlightFeatureEnabled: Boolean
  isBreakoutRoomsFeatureEnabled: Boolean
  isNdiEnabled: Boolean
  isCompositorEnabled: Boolean
  """
  Flag to indicate if raise hands is allowed in the call. A presenter can allow or disallow raise hands for everyone in a call
  """
  isRaiseHandsAllowed: Boolean
  conversationId: String
  transferorMri: String
  isFake: Boolean
  dominantSpeakerInfo: DominantSpeakerInfo!
  messageId: String
  isSystemAudioShared: Boolean
  isBackgroundBlurOn: Boolean
  isIncomingVideoOn: Boolean
  screenSharingControlStateAsViewer: ScreenSharingControlStateAsViewer
  broadcastMeeting: BroadcastMeeting
  isBroadcast: Boolean
  extendedCallType: ExtendedCallType
  terminatedReason: Int
  failureType: Int
  abortReason: CallAbortReason
  callEndDiagnosticsInfo: CallEndDiagnosticsInfo
  capabilities: CallCapabilities
  pstnCapabilities: PstnCapabilities
  breakoutRoomsParticipantDetails: ParticipantMainMeetingDetails
  breakoutRoomsCount: Int
  breakoutRoomDetails: BreakoutroomDetails
  isBreakoutRoomInvite: Boolean
  isMainMeetingInvite: Boolean
  vdiCapabilities: VdiCapabilities
  vdiEnvSettings: VdiEnvSettings
  hadRelayWhitelistingIssue: Boolean
  hadReconnectingIssue: Boolean
  isRoomEndedByOrganizer: Boolean
  isRoomEndedByTimer: Boolean
  initiatedTime: BigInt
  wasNotAdmittedForLongTime: Boolean
  canBeRetried: Boolean
  isRejoinable: Boolean
  isVideoLive: Boolean
  isScreenShareLive: Boolean
  callStateProps: CallStateProps
  meetingRole: String
  canAddParticipants: Boolean
  callerMri: String
  selfCapabilities: SelfCapabilities
  callHeldAt: Float
  consultContext: ConsultContext
  emergencyCallInfo: EmergencyCallInfo
  reconciledOriginalId: String
  forwardingDestinationType: String
  isPresenterConnected: Boolean
  optimalVideoCount: Int
  areAttendeesRestricted: Boolean
  timeZoneOffset: Int
  mappedToMeetingRoom: ID
  closedCaptionsLanguage: String
  hasOverflowRoom: Boolean
  isWeatherpersonCompositionEnabled: Boolean
  isWeatherpersonPresenterEnabled: Boolean
  isPPTWeatherpersonEnabled: Boolean
  isExtensibleAppWeatherpersonEnabled: Boolean
  isPPTCameoEnabled: Boolean
  isPPTSbSAndReporterEnabled: Boolean
  isCameoPresenterEnabled: Boolean
  isWatermarkEnabled: Boolean
  supportedSharingLayouts: [SharingLayoutMode!]
  isMovePrivateViewingToPPTEnabled: Boolean
  meetingArtifacts: MeetingArtifactsCollection
  meetingDetails: CallMeetingDetails
  meetingData: MeetingData
  meetingEndToEndEncryptionEnabled: Boolean
  meetingInterpretationDetails: MeetingInterpretationDetails
  selfInterpretationDetails: ParticipantInterpretationDetails
  appliedInteractivityLevel: String
  sharingPresenterIds: [String]
  isAnnotationSharerWindowOn: Boolean
  participantCounts: ParticipantCounts
    @deprecated(reason: "Use callParticipantsCount instead.")
  shouldAutoRejoin: Boolean
  isHighFidelityAudioEnabled: Boolean
  stagingRoomProperties: StagingRoomProperties
  rtmpInProperties: RTMPInProperties
  aplCustomBackgroundId: String
  isAplCustomBackgroundEnabled: Boolean
  isCoachSupported: Boolean
  isPushToTalkEnabled: Boolean
  isOnStage: Boolean
  isTogetherModePinned: Boolean
  screenSharingBounds: ScreenSharingBounds
  callLimits: CallLimits
  meetingInfo: MeetingInfoCall
  isImmersiveViewActive: Boolean
  isImmersiveViewActiveLoading: Boolean
  isVideoExtensibilityOn: Boolean
  isAvatarOn: Boolean
  userEndpointCount: Int
  isAppHandlingAudio: Boolean
  displayNameOverride: String
  brandingInfo: MeetingBrandingInfo
  acceptedElsewhereBy: User
  transcriptOrganizerId: String
  transferTargetDisplayName: String
  maskedIdentityDetails: MaskedIdentityDetails
  intent: CallingIntentInfo
  participants: [User!]
  isServerHold: Boolean
}

type CallingIntentInfo {
  id: ID!
}

type MeetingBrandingInfo {
  defaultTheme: String
  meetingBrandingThemes: [MeetingBrandingTheme!]
  lobbyLogoBrandingImages: [LobbyLogoBrandingImage!]
}

type LobbyLogoBrandingImage {
  imageUri: String!
}

type MeetingBrandingTheme {
  identity: ID
  displayName: String
  enabled: Boolean!
  brandAccentColor: String
  logoImageLightUri: String
  logoImageDarkUri: String
  backgroundImageLightUri: String
  backgroundImageDarkUri: String
}

type MeetingInfoCall {
  tenantId: String!
  organizerId: String!
  organizerUpn: String
}

type CallLimits {
  remainingDurationInMinutes: Int
  maxAllowedParticipants: Int
  sponsor: String
  enforcePaywallLimits: Boolean
}

type CallMeetingDetails {
  meetingCapability: CallMeetingCapabilies

  """
  Exchange Id of the Calendar Event. For recurring meetings, this is associated to the recurring master event.
  """
  exchangeId: String
    @deprecated(
      reason: "Use masterEventDetails for series master's exchangeId. For Single meeting or occurrence of a recurring - use eventDetails."
    )
  """
  iCalUid of the Calendar Event. For recurring meetings, this is associated to the recurring master event.
  """
  iCalUid: String
    @deprecated(
      reason: "Use masterEventDetails for series master's iCalUid. For Single meeting or occurrence of a recurring - use eventDetails."
    )

  """
  For recurring meetings only. This will contain the recurring master's event dettails
  """
  masterEventDetails: CallMeetingEventDetails

  """
  For single and recurring meetings. This will contain the meeting's event details
  """
  eventDetails: CallMeetingEventDetails

  isChannelMeeting: Boolean
  isPrivateMeeting: Boolean
  isRecurring: Boolean
  meetingType: MeetingType
  meetingJoinUrl: String

  """
  deprecated property, need to remove its references
  """
  meetingArtifacts: MeetingArtifactsCollection

  templateDetails: TemplateDetails

  anyWaterMarkLegacyUserEverInMeeting: Boolean
}

"""
CallMeetingEventDetails is an abstraction of meeting information based on chat thread and calendar event provided by service.
This is to expose meeting information of private and channel meetings.
"""
type CallMeetingEventDetails {
  id: ID!
  endTime: DateTime
  eventType: AppointmentType
  iCalUid: String
  isCancelled: Boolean
  startTime: DateTime
  subject: String

  # For recurring masters
  eventRecurrencePattern: RecurrencePattern
  eventRecurrenceRange: RecurrenceRange
}

type CallMeetingCapabilies {
  lockMeeting: Boolean
  allowMeetingReactions: Boolean
  isHostViewModeActive: Boolean
  yammerQNAEnabled: Boolean
  breakoutRoomsEnabled: Boolean
  watermarkScreenShareEnabled: Boolean
  watermarkScreenShareSettings: WatermarkCustomizationSettings
  watermarkVideoEnabled: Boolean
  watermarkVideoSettings: WatermarkCustomizationSettings
  sensitivityLabelId: String
  meetingEndToEndEncryptionEnabled: Boolean
  forceAttendeeStreaming: Boolean
  maskIdentitiesForRole: Boolean
  streamingModeActive: Boolean
  isCopyRestrictionEnforced: Boolean
  allowTranslatedCaptions: Boolean
  enableParticipantRenaming: Boolean
  isPresenterCapabilitiesReduced: Boolean
  hasCommentStream: Boolean
  autoAdmittedUsers: AutoAdmittedUsersOption
  presenterOption: WhoCanPresentOption
}

type TemplateDetails {
  id: String
}

type InterpretationGroup {
  id: String!
  label: String
}

type BroadcastMeeting {
  composerStreamId: Int
  broadcastState: BroadcastState
  role: String
  commands: BroadcastProducerAvailableCommands
  broadcastMaxAllowedDuration: Int
}

type BroadcastState {
  status: BroadcastStatus
}

type BroadcastProducerAvailableCommands {
  start: Boolean!
  stop: Boolean!
  setLayout: Boolean!
  updateMediaState: Boolean
  restart: Boolean
}

enum BroadcastStatus {
  NotStarted
  Starting
  Started
  Stopping
  Stopped
}

enum CallAbortReason {
  Offline
  InitFailed
  JoinFailed
  AcceptFailed
}

type CallEndDiagnosticsInfo {
  callControllerCode: Int
  callControllerSubCode: Int
}

union CallCoordinates =
    LegacyMeetingCoordinates
  | MeetingDataCoordinates
  | ExistingCallCoordinates
  | OneToOneCoordinates
  | GroupCallCoordinates

union CallJoinOptions =
    JoinOptions
  | MeetingJoinOptions
  | OneToOneJoinOptions
  | GroupCallJoinOptions

type ExistingCallCoordinates {
  teamsCallId: ID!
  callType: String
}

type OneToOneCoordinates {
  mri: ID!
  conversationId: ID
}

type NoiseSuppressionSetting {
  support: NoiseSuppressionSupport
  mode: NoiseSuppressionMode
}

enum NoiseSuppressionSupport {
  None
  Normal
  Deep
  PNS
}

enum NoiseSuppressionMode {
  Auto
  High
  Low
  Medium
  None
}

type GroupCallCoordinates {
  """
  required if creating new group call
  """
  participants: [ID!]
  """
  required if existing group chat
  """
  conversationId: ID

  """
  required for an ACS group call
  """
  groupId: ID
}

type MeetingDataCoordinates {
  joinType: MeetingJoinType!
  meetingData: MeetingData!
  isAdhoc: Boolean!
  meetingCloud: String
  participantPin: String
}

type MeetingData {
  meetingCode: String
  passcode: String
  meetingUrl: String
}

type LegacyMeetingCoordinates {
  joinType: MeetingJoinType!
  conversationId: ID
  messageId: ID!
  rootMessageId: ID!
  isChannel: Boolean!
  isAdhoc: Boolean!
  tenantId: ID!
  organizerId: ID!
  meetingCloud: String
  skypeTeamsMeetingUrl: String
  broadcast: BroadcastPayload
  participantPin: String
  registration: RegistrationPayload
}

type BroadcastPayload {
  role: BroadcastParticipantRole!
}

type RegistrationPayload {
  participantRegistrationId: String!
  isPublicEvent: Boolean
}

type JoinOptions {
  outgoingVideo: Boolean
  outgoingAudio: Boolean
  incomingVideo: Boolean
  incomingAudio: Boolean
  context: String
  CQFCallId: String
  retryCount: Int
  audioUsageMode: AudioUsageMode
  splitGalleryDisabled: Boolean
  homeCloud: String
}

type ConsultationContext {
  subjectTeamsCallId: ID!
}

type MeetingJoinOptions {
  outgoingVideo: Boolean
  outgoingAudio: Boolean
  incomingVideo: Boolean
  incomingAudio: Boolean
  context: String
  title: String
  isCast: Boolean
  isPSTN: Boolean
  showPrejoin: Boolean
  showCompanionSelection: Boolean
  useLightweight: Boolean
  participantsToAdd: [ID!]
  deeplinkId: ID
  launchAgent: String
  showScreensharingPanel: Boolean
  CQFCallId: String
  displayName: String
  homeCloud: String
  splitGalleryDisabled: Boolean
  isWatchParty: Boolean
}

type OneToOneJoinOptions {
  outgoingVideo: Boolean
  outgoingAudio: Boolean
  incomingVideo: Boolean
  incomingAudio: Boolean
  context: String
  isPSTN: Boolean
  homeCloud: String
  """
  deprecated property, need to remove its references
  """
  shareDesktop: Boolean
  sharingSourceId: String
  consultationContext: ConsultationContext
  CQFCallId: String
  showCompanionSelection: Boolean
  splitGalleryDisabled: Boolean
}

type GroupCallJoinOptions {
  outgoingVideo: Boolean
  outgoingAudio: Boolean
  incomingVideo: Boolean
  incomingAudio: Boolean
  context: String
  sharingSourceId: String
  CQFCallId: String
  showCompanionSelection: Boolean
  splitGalleryDisabled: Boolean
  homeCloud: String
}

enum CallingIntentType {
  OngoingCall
  Meeting
  OneToOneCall
  GroupCall
}

enum MeetingJoinType {
  Legacy
  MeetingData
}

type CallingIntent {
  id: ID!
  type: CallingIntentType!
  coordinates: CallCoordinates!
  joinOptions: CallJoinOptions!
  activeScenarios: [CallingScenario!]
  mainScenario: CallingScenario
  prejoinCapabilities: CallPrejoinCapabilities
  retriedIntentId: ID
}

type Questionnaire {
  type: FeedbackType!
  isRateable: Boolean!
  duration: Float!
  questionnaireItemsByType: [QuestionnaireItemsByType!]!
  feedbackCallType: FeedbackCallType
  useRatingOnly: Boolean
  isSampledForPostCallCQF: Boolean
  experimentTag: String
  organizerId: String
}

enum FeedbackType {
  """
  regular Mean Opinion Score feedback
  """
  Quality
  """
  special feedback for calls that were canceled shortly after getting connected (within 5s from being connected)
  """
  ShortDurationHangup
  """
  special feedback for effective meeting feedback
  """
  EffectiveMeeting
  """
  v2 for effective meeting feedback
  """
  EffectiveMeetingV2
  """
  Viva version effective meeting feedback shown to users who opted into Viva EMF
  """
  EffectiveMeetingViva
}

type QuestionnaireItemsByType {
  itemType: QuestionnaireItemType!
  items: [QuestionnaireItem!]!
}

enum QuestionnaireItemType {
  Audio
  AttendeeAudio
  Video
  ScreenSharing
  Broadcast
  ScreenshareFromChat
  AttendeeGeneral
  AttendeeCaptions
  CallClosedCaptions
  EffectiveMeeting
  Other
}

type QuestionnaireItem {
  category: String!
  token: Int!
  id: ID!
  editLength: Int
  isStarRating: Boolean
}

enum FeedbackCallType {
  P2P
  GroupCall
  Meeting
  ScreenshareFromChat
  PSTN
  SfB
}

input QuestionnaireItemInput {
  id: ID!
  value: String
}

"""
union types are not supported for input
"""
input CallCoordinatesInput {
  legacyMeeting: LegacyMeetingCoordinatesInput
  meetingData: MeetingDataCoordinatesInput
  oneToOne: OneToOneCoordinatesInput
  existingCall: ExistingCallCoordinatesInput
  groupCall: GroupCallCoordinatesInput
}

input ExistingCallCoordinatesInput {
  teamsCallId: ID!
  callType: String
}

input OneToOneCoordinatesInput {
  mri: ID!
  conversationId: ID
}

input GroupCallCoordinatesInput {
  participants: [ID!]
  conversationId: ID
  groupId: ID
}

input LegacyMeetingCoordinatesInput {
  conversationId: ID!
  messageId: ID!
  rootMessageId: ID!
  isChannel: Boolean!
  isAdhoc: Boolean!
  tenantId: ID!
  organizerId: ID!
  meetingCloud: String
  broadcast: BroadcastPayloadInput
  registration: RegistrationPayloadInput
  instantMeetingOptions: InstantMeetingOptionsInput
  participantPin: String
}

input MeetingDataCoordinatesInput {
  meetingCode: String
  passcode: String
  meetingUrl: String
  isAdhoc: Boolean
  instantMeetingOptions: InstantMeetingOptionsInput
  participantPin: String
}

input InstantMeetingOptionsInput {
  # Make 'id' field optional for TSW compatibility, but it is required.
  # TODO (#3031621): Make instant meeting id required field once TSW is updated
  id: ID
  existingEvent: SchedulingServiceEventInput
}

input BroadcastPayloadInput {
  role: BroadcastParticipantRole!
}

input RegistrationPayloadInput {
  participantRegistrationId: String!
  isPublicEvent: Boolean
}

enum AudioUsageMode {
  Default
  LongrangeSpeaker
  Auditorium
}

"""
representation of collab object
"""
type MeetingArtifactsCollection {
  id: ID
  changeKey: String
  resources: [MeetingArtifactV2Union!]
  errorState: MeetingArtifactsErrorState
}

union MeetingArtifactV2Union =
    MeetingArtifactV2Transcript
  | MeetingArtifactV2Recording
  | MeetingArtifactV2Notes
  | MeetingArtifactV2MeetingContent
  | MeetingArtifactV2Default

"""
Representation of error state of collab object
"""
type MeetingArtifactsErrorState {
  code: Int
  subCode: Int
  subError: String
}

"""
Representation of a basic meeting artifact as returned by the underlying service
"""
interface MeetingArtifactV2Interface {
  """
  Optional identifier for the resource
  """
  id: ID
  """
  Type of the meeting artifact
  """
  type: MeetingArtifactType!
  """
  Url which can be used to retrieve the content of the meeting artifact
  This value must be unique across all meeting artifacts associated with
  a meeting.
  """
  location: String!
  """
  The name of the app for generic resourceTypes (ex: MeetingStage, MeetingChat, etc...)
  """
  subType: String
}

type MeetingArtifactV2Transcript implements MeetingArtifactV2Interface {
  id: ID!
  type: MeetingArtifactType!
  location: String!
  subType: String

  """
  callId of the call
  """
  callId: String
  """
  groupId of the meeting which is relevant for group meeting
  """
  groupId: String
  """
  messageId of the meeting
  """
  messageId: String
  """
  organizer of the transcript in the form of "oid_of_user@tenantId_of_user"
  """
  organizerId: String
  """
  start time of the transcript
  """
  startTime: String
  """
  state of the transcript. Possible values are "Started" and "Completed"
  """
  state: String
  """
  threadId of the meeting
  """
  threadId: String
}

type MeetingArtifactV2Recording implements MeetingArtifactV2Interface {
  id: ID!
  type: MeetingArtifactType!
  location: String!
  subType: String

  """
  url of the thumbnail of the recording
  """
  thumbnailUrl: String
  """
  callId of the call
  """
  callId: String
  """
  duration of the recording
  """
  duration: String
  """
  oid of the owner of the recording
  """
  ownerOid: String
  """
  tid of the owner of the recording
  """
  ownerTid: String
  """
  start time of the recording
  """
  startTime: String
  """
  threadId of the recording
  """
  threadId: String
  """
  thread messageId of the recording
  """
  threadMessageId: String

  """
  driveId of the recording
  """
  driveId: ID
  """
  driveItemId of the recording
  """
  driveItemId: ID
}

type MeetingArtifactV2Notes implements MeetingArtifactV2Interface {
  id: ID!
  type: MeetingArtifactType!
  location: String!
  subType: String

  """
  Supports "notes" artifact type, used to determine if the
  fluid object is enabled or not
  """
  state: String
  """
  Supports "notes" artifact type, used to determine if the
  fluid object is for a series or instance
  for series isShared === true
  """
  isShared: String
  """
  Supports "notes" artifact type, used to determine the
  sharing link scope.
  For CSL linkScope === organization, for PSL scope linkScope === users
  """
  linkScope: String
  """
  Supports "notes" artifact type, used to determine the
  host client. Possible values are TeamsCalendarScheduling, TeamsCalendarDetailsPage, TeamsInMeeting
  """
  hostClient: String
}

type MeetingArtifactV2MeetingContent implements MeetingArtifactV2Interface {
  id: ID!
  type: MeetingArtifactType!
  location: String!
  subType: String

  """
  Supports "meetingContent" type, appId is unique for each app
  """
  appId: ID
  """
  Supports "meetingContent" type, title of the shared app, ex: Excel, Word
  """
  appTitle: String
  """
  Supports "meetingContent" type, title of the shared file
  """
  fileTitle: String
  """
  Supports "meetingContent" type, image url of the shared app
  """
  imageUrl: String
  """
  Supports "meetingContent" type, userId is refer to the presenter who start sharing app
  """
  userId: ID
  """
  For more generic meeting content type to use, include ppt/whiteboard/excel and other apps
  Combine all metadata into one object string, to get rid of metadata type limitation
  """
  meetingContentMetadataObject: String
  """
  Properties for service correlation
  """
  correlationProperties: CorrelationProperties
}

type MeetingArtifactV2Default implements MeetingArtifactV2Interface {
  id: ID!
  type: MeetingArtifactType!
  location: String!
  subType: String
  linkScope: String
  hostClient: MeetingAgendaHostClient
  """
  appId is unique for each app
  """
  appId: ID
  """
  title of the shared app, ex: Excel, Word
  """
  appTitle: String
  """
  title of the shared file
  """
  fileTitle: String
  """
  image url of the shared app
  """
  imageUrl: String
  """
  userId is refer to the presenter who start sharing app
  """
  userId: ID
  """
  baseUrl refers to the base URL of the file
  """
  baseUrl: String
  """
  objectUrl refers to the object URL of the file
  """
  objectUrl: String
  """
  shareUrl refers to the shareable URL of the file
  """
  shareUrl: String
  """
  Refers to the type of the file, like docx
  """
  fileType: String
  """
  Unique identifier for a file
  """
  fileId: String
  """
  includes ppt/whiteboard/excel and other apps
  Combine all metadata into one object string, to get rid of metadata type limitation
  """
  meetingContentMetadataObject: String
}

enum MeetingArtifactType {
  MeetingCoach
  MeetingInfo
  MeetingInfoV3
  AttendanceReport
  AttendanceReportV3
  ExternalParticipants
  ExplicitActionItems
  ImplicitActionItems
  Decisions
  Notes
  Playground
  ManualActionItems
  NgcParticipantsActivity
  Transcript
  TranscriptEntities
  TranscriptEvents
  Recording
  MeetingContent
  MeetingStage
  MeetingChat
  Attachment
  Recommendation
  TranscriptV2
}

enum WorkingSetFilesType {
  RecordingAndTranscriptFromWorkingSet
  RecordingFromWorkingSet
}

input JoinOptionsInput {
  isTransfer: Boolean
  outgoingVideo: Boolean
  outgoingAudio: Boolean
  incomingVideo: Boolean
  incomingAudio: Boolean
  context: String
  meeting: MeetingJoinOptionsInput
  oneToOne: OneToOneJoinOptionsInput
  groupCall: GroupCallJoinOptionsInput
  consultationContext: ConsultationContextInput
  audioUsageMode: AudioUsageMode
  weatherpersonCapable: Boolean
  splitGalleryDisabled: Boolean
  homeCloud: String
}

input MeetingJoinOptionsInput {
  title: String
  isCast: Boolean
  isPSTN: Boolean
  showPrejoin: Boolean
  useLightweight: Boolean
  participantsToAdd: [ID!]
  roomParticipantToAdd: RoomInput
  roomParticipantInMeeting: RoomInput
  deeplinkId: ID
  showScreensharingPanel: Boolean
  displayName: String
  sharingSourceId: String
  pptSharingSource: PptSharingContentInput
  shareSystemAudioCasting: Boolean
  homeCloud: String
  splitGalleryDisabled: Boolean
  isWatchParty: Boolean
}

input OneToOneJoinOptionsInput {
  """
  deprecated property, need to remove its references
  """
  shareDesktop: Boolean
  sharingSourceId: String
}

input GroupCallJoinOptionsInput {
  sharingSourceId: String
}

input ConsultationContextInput {
  subjectTeamsCallId: ID!
}

type DominantSpeakerInfo {
  speakerList: [ID!]!
  timestamp: Float
}

type StreamDetailsInfo {
  id: ID!
  streamInformation: [StreamDetail!]
}

type Participant {
  id: ID!
  state: Int!
  stateReason: Int
  displayName: String
  isServerMuted: Boolean
  isReconciled: Boolean
  isHandRaised: Boolean
  raiseHandsRank: Int
  raiseHandsOrderedRank: Int
  isSpotlighted: Boolean
  isStreamingAttendee: Boolean
  spotlightRank: Int
  isDominantSpeaker: Boolean
  streams: [ParticipantStream!]
  isFake: Boolean
  audio: ParticipantStream
  isVideoLive: Boolean
  isScreenShareLive: Boolean
  meetingRole: String
  stateProps: ParticipantStateProps
  contentSharingRole: Int
  participantId: ID
  visible: Boolean
  holographicDevice: HolographicDeviceType
  timeZoneOffset: Int
  endpoints: [EndpointDetails!]
  weathermanModeDetail: WeathermanModeDetail
  isManagingBreakoutRooms: Boolean
  mappedTo: String
  mappedToMeetingRoom: ID
  isOnStage: Boolean
  deviceType: ClientDeviceType
  interpretationDetails: ParticipantInterpretationDetails
  joinCorrelationId: Int
  isInSameRoom: Boolean
  isIdentityMasked: Boolean
  nonMaskedId: ID
  nonMaskedDisplayName: String
  maskedIdSeqNumber: Int
  displayNameOverride: String
  tenantId: ID
  hasCloudIntelliFrame: Boolean
}

type ParticipantInterpretationDetails {
  isInterpreter: Boolean!
  group: InterpretationGroup
}

type MeetingInterpretationDetails {
  hasInterpretation: Boolean!
  groups: [InterpretationGroup!]
  floor: [InterpretationGroup!]!
}

type BasicParticipant {
  id: ID!
  state: Int!
  displayName: String
  participantId: ID!
  meetingRole: String
  nonMaskedId: ID
}

type WeathermanModeDetail {
  isWeatherpersonPresenter: Boolean
  """
  this is only for the presenter overlay
  """
  overlayCoords: String
}

enum ClientDeviceType {
  Default
  Room
}

type EndpointDetails {
  endpointId: String
  endpointMetadata: EndpointMetadata
  clientEndpointCapabilities: ClientEndpointCapabilities
  originalId: String
  participantId: String
  mappedTo: String
}

type StreamDetail {
  id: ID!
  urls: [String]
  decryptionKey: StreamDecryptionKey
  isPrimary: Boolean
  deliveryPipelineType: StreamDeliveryPipelineType
  setKeyAuthorizationCookieUri: String
  keyAuthorizationToken: String
  setCookieUrl: String
  sdn: StreamSdnDetail # Software Defined Network
  transcription: StreamTranscriptionData
}

type StreamTranscriptionData {
  cacheUrl: String
  originUrl: String
  isEnabled: Boolean
  spokenLanguage: String
  tracks: [String!]
  aesKey: AESKey
  locale: StreamTranscriptionLocale
}

enum StreamTranscriptionLocale {
  BCP
}

type AESKey {
  key: String!
  iv: String!
  expiry: String!
  id: String!
}

# Software Defined Network
type StreamSdnDetail {
  sdnName: String
  sdnPlaybackInfo: String
  sdnPluginUrl: String
  sdnSdkUrl: String
}

type StreamDecryptionKey {
  key: String
  value: String
}

enum StreamDeliveryPipelineType {
  AMS
  MiddleLaneUltraLowLatency
  MiddleLaneHttpLiveStreaming
}

type EndpointMetadata {
  audienceview: AudienceViewMetadata
  botData: BotMetaData
  meetingRoom: MeetingRoom
}

type MeetingRoom {
  mri: ID!
  email: ID!
}

type AudienceViewMetadata {
  id: ID!
  status: String!
  page: Int
  type: String!
}

enum BotSourceType {
  RTMPInput
}

type BotMetaData {
  id: ID!
  hiddenParticipant: Boolean!
  hiddenStream: Boolean!
  canBeMutedAndUnMuted: Boolean!
  page: Int
  role: String
  type: BotSourceType
}

type ClientEndpointCapabilities {
  CanSupportBreakOutRoom: Boolean
  supportsStreaming: Boolean
}

type VideoAspectRatio {
  width: Int!
  height: Int!
}

type MediaDeviceCapabilities {
  videoAspectRatio: VideoAspectRatio
}

type ParticipantStream {
  id: Int
  isAvailable: Boolean
  isStreaming: Boolean
  type: StreamType
  rank: Int
  negotiationTag: String
  participantLegId: String
  label: StreamLabel
  endpointId: ID
  """
  Media source ID
  """
  sourceId: Int
  """
  Represents virtual participant, displayed on the video stream
  """
  dynamicVirtualParticipantId: String
  """
  Represents device capabilities, such as video aspect ratio
  """
  mediaDeviceCapabilities: MediaDeviceCapabilities
}

type ParticipantStateProps {
  icon: String!
  description: String!
  error: String
  useOutlineIcon: Boolean
}

enum StreamType {
  Video
  ScreenSharing
}

enum StreamLabel {
  Audio
  Video
  PanoramicVideo
  ScreenShare
  Data
  ParticipantVideo_0
  ParticipantVideo_1
  ParticipantVideo_2
  ParticipantVideo_3
}

scalar MeetingOptionsTranslations
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

type CallRecording {
  videoTitle: String
  videoUrl: String
  thumbnailUrl: String
  timestamp: String
  duration: String
  callId: String
}

type ParticipantCounts {
  id: ID
  totalParticipants: Int!
  totalConnectedTflParticipants: Int!
  lobbyParticipants: Int!
  totalPresenters: Int!
  requestingAttentionPresenters: Int!
  totalAttendees: Int!
  requestingAttentionAttendees: Int!
  overflowAttendees: Int
  streamingAttendees: Int
}

type MeetingParticipantCount {
  id: ID!
  totalParticipantAndThreadMembers: Int!
}

type WhiteboardSharingContentDto {
  id: ID!
  url: String!
  shareUrl: String!
  type: String
  initiatorParticipantId: String
  permittedFileUsers: [String] @deprecated(reason: "Use extensibleAppContext")
  pendingFilePermittedUsers: [String]
    @deprecated(reason: "Use extensibleAppContext")
  failedFilePermittedUsers: [String]
    @deprecated(reason: "Use extensibleAppContext")
  extensibleAppContext: String
  initialNoteContent: [String]
  meetingType: String
}

"""
Will replace WhiteboardSharingContentDto in order to make code flow more generic
"""
type CallAppContentSharingDto {
  id: ID!
  url: String!
  shareUrl: String!
  type: String
  initiatorParticipantId: String
  extensibleAppContext: String
}

type WhiteboardSharingSession {
  id: ID!
  content: WhiteboardSharingContentDto!
  mode: WhiteboardSharingContentMode!
  isInitiator: Boolean
  isNativeApp: Boolean
}

"""
Will replace WhiteboardSharingSession in order to make code flow more generic
"""
type CallAppContentSharingSession {
  id: ID!
  content: CallAppContentSharingDto!
  mode: CallAppContentSharingMode!
  isInitiator: Boolean
  isNativeApp: Boolean
}

type Room {
  address: String!
  audioDeviceName: String
  bookingType: RoomBookingType
  building: String
  buildingAddress: String
  capacity: Int
  displayDeviceName: String
  floorLabel: String
  floorNumber: String
  geoCoordinates: GeoCoordinates
  id: String
  isAlreadyInMeeting: Boolean
  isAlreadyInAnyMeeting: Boolean
  isWheelChairAccessible: Boolean
  label: String
  meetingHash: String
  name: String!
  nickname: String
  phone: String
  physicalAddress: PhysicalAddress
  placeType: PlaceType
  proximityValidationCode: Int
  rssi: Int
  tags: [String]
  userId: ID
  videoDeviceName: String
  peripherals: [Peripheral!]
}

type PeripheralMetadata {
  deviceId: String
  connectionType: Int
  isSystemDefault: Boolean
}

type Peripheral {
  productId: String
  vendorId: String
  serialNumber: String
  model: String
  peripheralType: String
  metadata: PeripheralMetadata
}

type BringYourOwnDeviceRooms {
  requestId: String
  rooms: [Room!]
  unassociatedDevices: [Peripheral!]
}

enum RoomBookingType {
  Unknown
  Standard
  Reserved
}

enum PlaceType {
  Room
  Workspace
  RoomList
}

type GeoCoordinates {
  accuracy: Float
  altitude: Float
  altitudeAccuracy: Float
  latitude: Float
  longitude: Float
}

type PhysicalAddress {
  city: String
  countryOrRegion: String
  postalCode: String
  state: String
  street: String
}

input RoomInput {
  userId: ID!
  displayName: String!
  proximityValidationCode: Int
}

type CallParticipantReaction {
  participantId: ID!
  meetingReaction: MeetingReactionType!
  skinTone: Int
  isMasked: Boolean
  maskedId: String
  aggregatedCount: Int
}

enum Availability {
  PresenceUnknown
  Available
  AvailableIdle
  Away
  Busy
  BusyIdle
  DoNotDisturb
  BeRightBack
  Offline
}

"""
Set by unified presence server
"""
enum Activity {
  InACall
  InAConferenceCall
  InAMeeting
  Presenting
  OffWork
  Available
  Inactive
  Busy
  DoNotDisturb
  BeRightBack
  Away
  Offline
  UrgentInterruptionsOnly
  PresenceUnknown
  OutOfOffice
}

type StatusNote {
  message: String!
  publishTime: String!
  expiry: String
}

enum UserFlwPresence {
  None
  OnShift
  OffShift
}

type Shift {
  teamId: String!
  teamName: String!
  """
  Shift start time
  """
  startTime: String!
  """
  Shift end time
  """
  endTime: String!
  """
  Shift role name
  """
  scheduleGroupDisplayName: String!
  """
  Shift team timezone code
  """
  teamOlsonCode: String!
}

type Shifts {
  previousShift: Shift
  currentShift: Shift
  nextShift: Shift
}

enum ChatType {
  Chat
  PhoneChat
  Phonelink1on1Chat
  PhonelinkGroupChat
  Meeting
  SfBInteropChat
}

"""
enum is from https://dev.azure.com/domoreexp/Teamspace/_git/teams-modular-packages?path=/packages/services/io/services-io-chat/src/csa-service-constants.ts
"""
enum ChatSubType {
  None
  Meeting
  Channel
}

enum InteropConversationStatus {
  AcceptPending
  Accepted
  Blocked
  Quarantined
  ExtendedDirectoryAcceptPending
}

enum PresenceLocationType {
  Unknown
  Office
  Remote
  TimeOff
}

type WorkLocation {
  location: PresenceLocationType!
  expiry: String
  isForced: Boolean!
}

type Presence {
  id: ID!
  availability: Availability
  activity: Activity
  isOutOfOffice: Boolean
  outOfOfficeMessage: String
  lastSeenAt: String
  """
  StatusNote is the status message set by the user which is displayed on LPC
  """
  statusNote: StatusNote
  flwPresence: UserFlwPresence
  flwShifts: Shifts
  isFocus: Boolean
  workLocation: WorkLocation
  """
  isForcedAvailability represents if presence was forcedly changed by the user
  """
  isForcedAvailability: Boolean
}

type ConsumptionHorizon {
  """
  convId
  """
  id: ID!
  """
  originalArrivalTime is in ISO date format
  """
  originalArrivalTime: String
  """
  timeStamp is in ISO date format
  """
  timeStamp: String
  clientMessageId: String
}

"""
Consumption Horizon Bookmark, aka User CH, is a manually set CH timestamp. A user can manually
set this when the user marks a message as unread. CH Bookmark has the same type as ConsumptionHorizon,
but CH Bookmark needs a distinct typing to overcome Apollo quirks. Otherwise, both properties
would have the same __typename and ID which leads to conflicts with the inMemory cache.
When we do not need to indicate its __typename, please use IConsumptionHorizonBookmark type
from @msteams/components-consumption-horizon package.
"""
type ConsumptionHorizonBookmark {
  """
  convId
  """
  id: ID!
  """
  originalArrivalTime is in ISO date format
  """
  originalArrivalTime: String
  """
  timeStamp is in ISO date format
  """
  timeStamp: String
  clientMessageId: String
}

"""
Typing user data of a given user
"""
type TypingUser {
  """
  User mri
  """
  userId: ID!
  """
  Typing event arrival time
  """
  arrivalTime: String!
}

enum MeetingChatPolicy {
  ChatEnabled
  ChatDisabled
  InMeeting
  ChatEnabledAnonymousDisabled
  InMeetingAnonymousDisabled
}

type ConversationMembers {
  id: ID!
  members: [User!]!
  meetingUserRole: PrivateMeetingChatUserRole
}

enum PrivateMeetingChatUserRole {
  Organizer
  Presenter
  Attendee
  None
}

"""
2 way SMS chat disable reason code
"""
enum DisableReasonCode {
  OptedOut
  Deprovisioned
  Claimed
}
"""
2 way SMS chat disable reason info
"""
type DisabledReason {
  code: DisableReasonCode!
  newlyCreatedUserId: String
}

"""
State of the conversation import for claimed conversations
"""
enum ClaimedConversationImportState {
  Importing
  Completed
}

"""
State of the conversation awareness live state with dynamic key
eg: key format is `awareness_conversationLiveState:<message_id>`
"""
type AwarenessLiveState {
  key: String!
  value: String!
}

"""
type of the channel thread subtypes
"""
enum ChannelThreadSubType {
  sharedChannel
  privateChannel
}

type Conversation implements IEdgeNode {
  id: ID!
  """
  user specified topic name
  """
  title: String
  """
  generated chat title based on user givenNames
  """
  shortTitle: String
  """
  generated chat title based on user fullNames
  """
  longTitle: String

  groupTemplate: String
  isDisabled: Boolean
  disabledReason: DisabledReason
  importState: ClaimedConversationImportState
  isOneOnOne: Boolean
  isOneOnOneBotChat: Boolean
  isBotBlocked: Boolean
  isRead: Boolean
  isHidden: Boolean
  isUserMember: Boolean
  isUserAnonymous: Boolean
  isModerator: Boolean
  replyPermission: ChannelReplyPermissions
  isAdmin: Boolean
  isFederated: Boolean
  isMeeting: Boolean
  isSfB: Boolean
  isLastMessageFromMe: Boolean
  meetingChatPolicy: MeetingChatPolicy
  chatSubType: Int
  lastMessage: LastMessage
  lastMessageSender: User
  lastContentMessageTime: String
  identityMaskEnabled: Boolean
  commentStreamPolicy: MeetingChatPolicy
  """
  deprecated. Use memberIds or membersLimited instead.
  """
  members: [User!]
  memberIds: [ID!]
  botMembers: [User!]
  hasFederatedUser: Boolean
  hasTflConsumerUser: Boolean
  hasEnterpriseUser: Boolean
  hasUnknownConsumerUser: Boolean
  hasUnknownEnterpriseUser: Boolean
  hasUnresolvedFederatedUser: Boolean
  hasTflSmsUnverifiedUser: Boolean
  hasTflSmsVerifiedUser: Boolean
  hasTypingUsers: Boolean
  """
  First 2 nonTeamsFederatedUsers displayName
  """
  nonTeamsFederatedUserLimitedNames: [String!]
  nonTeamsFederatedUsersLength: Int
  isChatDisabledForRecipients: Boolean
  isPrivateChatPolicyDefinedScenario: Boolean
  tflOffNetworkUser: User
  tflOffNetworkUserLength: Int
  hasBotMember: Boolean
  me: User
  """
  First 3 members, excluding me, bots and TFL Off Network users
  """
  membersLimited: [User!]
  """
  First 20 sorted displayNames, excluding me, bots and TFL Off Network users
  """
  memberDisplayNamesLimited: [String!]
  consumptionHorizon: ConsumptionHorizon
  consumptionHorizonBookmark: ConsumptionHorizonBookmark
    @deprecated(reason: "use userConsumptionHorizon")
  userConsumptionHorizon: ConsumptionHorizonBookmark
  smartReplySuggestions: SmartReplySuggestionCollection
    @deprecated(reason: "use quickReplyAugmentation")
  quickReplyAugmentation: QuickReplyAugmentation
  isMuted: Boolean
  creator: String
  chatType: ChatType
  """
  deprecated. Uses chatType instead.
  """
  type: ChatType
  meetingInformation: MeetingInformation
  isRetentionHorizonSet: Boolean
  tenantId: String
  """
  Identify if has recap in this chat
  """
  hasRecap: Boolean
  interopConversationStatus: InteropConversationStatus
  """
  Flag for conversations between TFW and TFL users that are part of TFW tenant's extended directory
  """
  extendedDirectoryRedemptionRequired: Boolean
  hiddenTime: String
  chatHistoryHiddenTime: String
  clearHistoryTime: String
  isDeleted: Boolean
  cfet: Boolean
  consumerGroupId: String
  typingUsers: [TypingUser!]
  userProperties: ConversationUserProperties
  substrateGroupId: String
  threadSubType: ChannelThreadSubType
  guardianChatInfo: String
  pinnedConversationItems: [PinnedConversationItemInfo!]
  picture: String
  gapDetectionEnabled: Boolean
  localClientId: String
  clientArrivalTime: String
  userAdminSettings: ConversationChannelUserAdminSettings
  awarenessLiveState: [AwarenessLiveState!]
  themeId: String
  addedBy: String
  addedByTenantId: String
  chatScheduleSuggestionSuppressUntil: String # suppress chat schedule message suggestions for this conversation until this time (ISO string timestamp)
  sensitivityLabel: SensitivityLabelConversation
  isCommentStream: Boolean
  quarantineCounter: Int
}

"""
User Admin settings related to conversation channel
"""
type ConversationChannelUserAdminSettings {
  deleteMessagesEnabled: Boolean
  adminDeleteEnabled: Boolean
}

"""
User specific properties related to the Conversation
"""
type ConversationUserProperties {
  """
  Whether the current user is restricted from replying and posting in the channel where this conversation occurs
  """
  isMutedInChannel: Boolean!
  """
  Current user's role in the conversation
  """
  role: ConversationMemberRole
  """
  Current user's maskId if user id is masked in the conversation
  """
  maskId: ID
}

"""
Member role relative to the Conversation
"""
enum ConversationMemberRole {
  None
  Admin
  User
  Guest
  Shadow
  Anonymous
}

type QuickReplyAugmentation {
  """
  The suggestedReplies Collections (e.g smart replies, schedualing suggestions)
  """
  suggestedRepliesCollections: [SuggestedRepliesCollection]
}

type SuggestedRepliesCollection {
  """
  The conversation id that is assoicated with this suggestion collection
  """
  convId: ID!
  """
  The time when the suggestions were computed (server side)
  """
  activityTimestamp: String!
  """
  The message id in the conversation for which this suggestion collection is created for(triggered for in SMAUG)
  """
  activityReplyToId: String!
  """
  The suggestions
  """
  suggestedReplies: [SuggestedReply!]!
}

type SuggestedReply {
  """
  The uniq id of the SR collection - in case of multiActivity needs to be part of the suggestion
  """
  whisperId: String!
  """
  Additional data relate to the suggestion
  """
  suggestionChannelData: SuggestionChannelData!
  """
  The suggestion text that is sent as the reply message
  """
  value: String!
  """
  The suggestion title. If not provided, the suggested reply value is shown instead
  """
  title: String
}

type SuggestionChannelData {
  """
  General Fields
  A Guid to identify each suggestion
  """
  id: ID!
  """
  Differentiate between the models generated the suggestions(e.g Undefined, Web, Mobile, Kingston)
  """
  device: String
  """
  Extraction time of the suggestion
  """
  utcTime: String!
  """
  The message id to which this suggestion should be rendered for
  """
  targetMessageId: String!
  """
  The type of the suggestion(e.g reply, meeting)
  """
  type: String!
  """
  The subtype of the suggestion(e.g summarize_calltranscript)
  """
  subType: String
  """
  Scheduling Suggestion (all can be null)
  """
  meetingTitle: String
  description: String
  startTime: String
  endTime: String
  callId: String
  storageId: String
  """
  In Viva Topics smart replies, it represents the request id for the KM API call that provider the suggestion
  """
  clientRequestId: String
  """
  In Viva Topics smart replies, it represents the annotationScore for the suggested reply
  """
  annotationScore: Float
}

"""
Smart reply chat suggestions
"""
type SmartReplySuggestionCollection {
  """
  The conversation id that is assoicated with this suggestion collection
  """
  convId: ID!
  """
  the time when the suggestions were computed (server side)
  """
  timestamp: String!
  """
  The message id in the conversation for which this suggestion collection is created for
  """
  replyMessageId: String!
  """
  The chat reply suggestion collection
  """
  suggestions: [SmartReplySuggestion!]!
  """
  The unique id of the SR collection
  """
  whisperId: String!
}

type SmartReplySuggestion {
  """
  The suggestion unique id, used for telemtery and correlation with the backend
  """
  channelDataId: ID!
  """
  The suggestion text
  """
  value: String!
  """
  The timestamp this suggestion was created
  """
  timestamp: String!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating reversed, the cursor to continue.
  """
  startCursor: String
  """
  When paginating forward, the cursor to continue.
  """
  endCursor: String
  """
  Are there more items in the direction of pagination?
  """
  hasNextPage: Boolean!
  """
  Are there more items in the direction of pagination?
  Keep hasPreviousPage optional for now until all the teams support it.
  https://domoreexp.visualstudio.com/MSTeams/_workitems/edit/2880619
  """
  hasPreviousPage: Boolean
}

"""
Information about sync info.
"""
type SyncInfo {
  """
  Are there stale data?
  """
  hasStaleData: Boolean!
}

"""
A connection to a list of edges.
"""
interface IConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [IEdge!]!
}

"""
An edge has metadata about one object in the paginated list
"""
interface IEdge {
  """
  A cursor to allow pagination starting from that object.
  """
  cursor: String
  """
  The actual item (object)
  """
  node: IEdgeNode!
}

"""
List of all possible edge node types used for the generic cursor based
pagination API
"""
interface IEdgeNode {
  id: ID!
}

"""
Message render types to be used for Message factory in Chat and Channel messages
"""
enum MessageRenderType {
  Standard
  MeetingControl
  MeetingRecording
  MeetingTranscript
}

enum MessageAttachedType {
  top
  bottom
}

"""
Tracks the state of current deeplink message
LOADED - implies that the message was found and loaded in current set of items
DELETED - if the deeplinked message is deleted
INVALID - the format of deeplinkMessageId was not correct. The expected format is a number that is represented by a string
NOTFOUND - indicates the message was not found in current set of items
"""
enum DeeplinkedMessageState {
  LOADED
  DELETED
  INVALID
  NOTFOUND
}

enum MeetingType {
  Unknown
  Adhoc
  Scheduled
  Recurring
  Broadcast
  MeetNow
}

type MeetingInformation {
  """
  convId
  """
  id: ID!
  subject: String
  meetingJoinUrl: String
  startTime: String
  scenario: String
  endTime: String
  iCalUid: String
  meetingType: MeetingType!
  meetingData: MeetingData
  isRecurring: Boolean
  isCancelled: Boolean
  organizerId: String
  tenantId: String
  location: String
  exchangeId: String
  eventType: AppointmentType
  eventRecurrenceRange: RecurrenceRange
  eventRecurrencePattern: RecurrencePattern
  resolvedSensitivityLabelId: String
  isCopyRestrictionEnforced: Boolean
  templateDetails: TemplateDetails
}

type EmotionUser {
  id: ID!
  time: Float
  value: String
}

type Emotion {
  key: String
  users: [EmotionUser!]
}

type EmotionSummary {
  key: String
  count: Int
}

type EscalationUser {
  mri: ID!
  time: Float
  """
  EscalationUserValue is parsed from this JSON string
  """
  value: String
}

type Escalation {
  key: EscalationModality
  users: [EscalationUser!]
}

enum EscalationModality {
  Email
  Call
  """
  Need to be deprecated in future iteration
  """
  PSTN
  SMS
  TeamsCall
  """
  Escalate to new person
  """
  ETNP
}

type Mention {
  id: ID!
  itemId: String
  userId: String
  mentionType: String
  displayName: String
}

type ATPSafelinksSharepointData {
  URL: String
  Xsdata: String
  Sdata: String
}

enum MessageStatus {
  Delivered
  Sending
  Error
  Undeliverable
}

enum MessageImportance {
  Standard
  Important
  Urgent
}

enum MessageReplyPermissions {
  Everyone
  AuthorAndOwners
  Undefined
}

enum PostType {
  Standard
  Announcement
  Email
  ScheduledMeeting
  InstantMeeting
  Connector
  Guardians
}

enum SmsDeliveryReportKey {
  Sent
  sent
  Failed
  failed
}

"""
Deep link attachment in a message
"""
type DeepLink {
  """
  Object Id
  """
  id: ID!
  """
  display name for the deeplink
  """
  title: String
  channelId: ID
  """
  site url for the deeplink
  """
  siteUrl: String
  serverRelativeUrl: String
  """
  object url for the deeplink
  """
  objectUrl: String
  """
  chiclet state
  """
  state: DeepLinkChicletState
}

type SharepointInfo {
  listId: String
  listItemId: String
  listItemUniqueId: String
  siteId: String
  siteUrl: String
  syncResourceId: String
  tenantId: String
  webId: String
  title: String
  type: String
  weight: Int
  bannerImageUrl: String
  bannerColor: String
  serverRelativeUrl: String
  siteLogoUrl: String
  url: String
}

type SharepointPublication {
  level: String
  versionId: String
}

type SharepointTemplate {
  id: String
}

type SharepointSite {
  dataLocationCode: String
  template: SharepointTemplate
}

"""
File attachment in message
isReferencedFile denotes whether the attached file is a reference to the existing file or newly created/uploaded
fileId unique id for a file on sharepoint side
baseUrl: base sharepoint url
objectUrl: full sharepoint url including file name
type: file type, i.e. docx, jpg, png
title: file name
preview fields are only present for images
"""
type File {
  """
  File object id
  """
  id: ID!
  """
  The unique identifier of the item within the Drive.
  """
  itemId: ID
  """
  Denotes whether the attached file is a reference to the existing file or newly created/uploaded
  """
  isReferencedFile: Boolean
  """
  Unique id of the file on Sharepoint side
  """
  fileId: String
  """
  Root url of the storage provider
  """
  baseUrl: String
  """
  Chiclet breadcrumbs
  """
  chicletBreadcrumbs: ChicletBreadcrumbs
  """
  Fully qualified url of the file attachment
  """
  objectUrl: String
  """
  Share id with which the file attachment has been shared
  """
  shareId: String
  """
  Share link with which the file attachment has been shared
  """
  shareUrl: String
  """
  File extension type
  """
  type: String
  """
  Name of the file
  """
  title: String
  """
  AMS preview url for image attachments
  """
  previewUrl: String
  """
  Height of the image attachment
  """
  previewHeight: Int
  """
  Width of the image attachment
  """
  previewWidth: Int
  anchorFileId: ID
  """
  state of the file chiclet
  """
  state: FileChicletState
  """
  From where the file is being uploaded
  """
  serviceName: FileViewServiceName
  """
  upload progress of the file for async upload
  """
  progressComplete: Int
  """
  permission scope set on the file
  """
  permissionScope: String
  """
  flag to denote if async upload has failed
  """
  hasUploadFailed: Boolean
  """
  providerData object which gets passed for 3P providers
  """
  providerDataV2: ProviderDataV2
  """
  context where file originated
  """
  context: String
  sharepointIds: SharepointInfo
  publication: SharepointPublication
  site: SharepointSite
}

type ProviderDataV2 {
  code: ExternalCloudStorageProviderCode!
  type: FilesProviderType!
}

type ChicletBreadcrumbs {
  sourceTeamName: String
  sourceChannelName: String
}

type SmsDeliveryReport {
  key: SmsDeliveryReportKey!
  users: [UserDeliveryReport!]
}

type UserDeliveryReport {
  mri: String!
  time: BigInt!
  """
  deprecated
  """
  errorCode: String
  value: String
}

type Card {
  appIcon: String
  appId: ID
  appName: String
  cardClientId: ID
  content: String!
  contentType: String!
  locale: String
  name: String
  userSpecificContent: UserSpecificCardContent
}

"""
User Specific View of the card
"""
type UserSpecificCardContent {
  content: String
  timeStamp: BigInt!
  version: String
  authBlockLastUsedOn: BigInt
}

enum CallQueueType {
  transfer
  conference
}

"""
This type represents the `call-log` prop bag item on a message once deserialized
"""
type CallLogItem implements IEdgeNode
  @model(
    tsType: "ICallHistoryItem"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  id: ID!
  """
  The call's direction
  """
  callDirection: CallDirection!
  """
  The call id
  """
  callId: String!
  callState: CallLogCallState!
  callType: CallLogCallType!
  callPhoneLineType: CallPhoneLineType
  """
  how long the call was connected in ms (comes in as date)
  """
  connectTime: String
  """
  date string representing the end of the call
  """
  endTime: String
  """
  The messageId from which the call log came form
  """
  messageId: String!
  """
  The participant who placed the call
  """
  originatorParticipant: CallLogParticipant!
  """
  The list of participants in a group call without bots and the current user
  """
  participantList: [CallLogParticipant!]!
  """
  start time of the call
  """
  startTime: String!
  """
  The participant to whom call was placed
  """
  targetParticipant: CallLogParticipant
  """
  used when a call is started from group chat/channel
  """
  threadId: String
  """
  The group call details like title, membersLimited
  """
  groupCall: Conversation
  """
  Determines CQ types and associated metadata
  """
  applicationContent: CallLogAppContent
  """
  The type of call session
  """
  sessionType: CallLogSessionType!
  """
  The call shared correlated ID
  """
  sharedCorrelationId: String!
  """
  Transcript info of the call
  """
  transcript: CallLogTranscript
  """
  Recordings info of the call
  """
  recordings: [CallLogRecording!]!
  """
  used to determine if the call is a spam call
  """
  spamRiskLevel: String
  userParticipantId: String
  """
  used to determine if the call has been deleted
  """
  isDeleted: Boolean
  """
  The participant who transfered the call
  """
  transferorParticipant: CallLogParticipant
  """
  The participant who the call got transferred to
  """
  transferTargetParticipant: CallLogParticipant
  """
  The status of the transferred call
  """
  transferStatus: CallLogTransferStatus
  """
  The transfer time
  """
  transferTime: String
  """
  The participant who forwarded the call
  """
  forwarderParticipant: CallLogParticipant
  """
  The participant who the call was forwarded to
  """
  forwardedTargetParticipant: CallLogParticipant
  """
  This is true for all Shared Line Appearance (SLA) calls on the shared history
  """
  isSharedLineAppearanceCallHistory: Boolean
  """
  This is true for all Shared Line Appearance (SLA) calls on the personal history
  """
  isSharedLineAppearanceActivated: Boolean
  """
  The forwarding type of the call.
  """
  forwardingType: CallForwardingType
  """
  The forwarded target type of the call
  """
  forwardedTargetType: CallForwardingTargetType
  """
  This will contain the delegator's information if the call originated from the Shared Line Appearance group
  """
  originatorDelegator: CallLogParticipant
  """
  This will contain the delegator's information if the call was targeted to the delegator
  """
  targetDelegator: CallLogParticipant
  """
  This will contain the information of everyone in the Shared Line Appearance group at the point of the call
  """
  sharedLineAppearanceParticipantList: [CallLogParticipant!]!
  """
  This contains the list of actions taken on the call by a member of the Shared Line Appearance (SLA) e.g. SLA hold/resume
  """
  sharedLineAppearanceCallActionList: [CallActionEvent!]!
  """
  Was this call missed?
  """
  isMissed: Boolean!
  """
  Was this call direction incoming?
  """
  isIncoming: Boolean!
  """
  Was this call direction outgoing?
  """
  isOutgoing: Boolean!
  """
  Was this call declined?
  """
  isDeclined: Boolean!
  """
  Was this call answered/accepted elsewhere?
  """
  isAcceptedElsewhere: Boolean!
  """
  Is this an emergency group call?
  """
  isEmergencyGroupCall: Boolean!
  """
  Is this a call queue call?
  """
  isCallQueue: Boolean!
  """
  The duration of the call in ms
  """
  durationInMs: Int!
  """
  The time as a string when the call was connected
  """
  originalArrivalTime: String!
  """
  The call log message type. It may be HTML, transcript, resording, etc.
  """
  messageType: String
  """
  Call start time converted to epoch
  """
  callStartTime: Float!
  """
  Call end time converted to epoch
  """
  callEndTime: Float

  # Following fields have a field resolver to resolve

  """
  What type of call queue call was this?
  """
  callQueueType: CallQueueType
  """
  The Call Queue Bot's MRI.
  """
  callQueueBotId: String
  """
  Is this a call queue call log for the current call queue
  """
  isForCurrentCallQueue(currentCallQueueId: String): Boolean
  """
  Is this a group call?
  """
  isGroupCall: Boolean
  """
  Is this a group call with PSTN user in the participant list?
  """
  isGroupCallWithPstn: Boolean
  """
  Is this a group call with regular user in the participant list?
  """
  isGroupCallWithUser: Boolean
  """
  Is the call a forwarded call?
  """
  isForwardedCall(currentTabDelegatorId: String): Boolean
  """
  Is the current user the participant who forwarded the call?
  """
  currentUserIsForwarder: Boolean
  """
  Did the current user answer the forwarded call?
  """
  currentUserAnsweredForwardedCall: Boolean
  """
  Show the forwarder info as the call history description
  """
  showForwarderAsCallHistoryDescription(currentTabDelegatorId: String): Boolean
  """
  Is the call a transferred call?
  """
  isTransferredCall: Boolean
  """
  Is the current user the participant who transfered the call?
  """
  currentUserIsTransferor: Boolean
  """
  Is the current user the participant who the call got transferred to?
  """
  currentUserIsTransferTarget: Boolean
  """
  Show the transferor info as the call history description
  """
  showTransferorAsCallHistoryDescription(currentTabDelegatorId: String): Boolean
  """
  Is a declined or missed immediately forwarded call from the POV of the forwarder
  """
  isDeclinedOrMissedImmediateForwardingForForwarder: Boolean
  """
  This is true when the outgoing Shared Line Appearance call was placed by another SLA member that is not the current user
  """
  sharedLineAppearanceCallInitiatedElsewhere: Boolean
  """
  Is the call is voicemail and is read
  """
  isRead: Boolean
  """
  Are all participants in this call pstn?
  """
  isPstnOnly(currentTabDelegatorId: String): Boolean
  """
  Display name to be shown for current row
  """
  displayName(currentTabDelegatorId: String): String

  """
  voicemail related fields
  """
  idIsEmail: Boolean
  isProtectedVoicemail: Boolean
  groupId: String
  mailboxId: String
  isOwnVoicemail: Boolean
}

type LinkedMessage
  @model(
    tsType: "ILinkedMessage"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  conversationId: ID!
  messageId: ID!
}

type CallLogRecording
  @model(
    tsType: "ICallLogRecording"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  conversationId: ID
  messageId: String
  initiatorId: ID
  content: String
  linkedMessage: LinkedMessage
}

type CallLogTranscript
  @model(
    tsType: "ICallLogTranscript"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  scopeId: ID
  linkedMessage: LinkedMessage
}

type CallActionEvent
  @model(
    tsType: "ICallActionEvent"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  callActionTime: String!
  callAction: CallAction!
  callActionOriginator: CallLogParticipant!
}

enum CallAction {
  Hold
  Resume
  Barge
}

enum CallLogSessionType {
  """
  call/meeting session type
  """
  Default
  """
  screenshare call
  """
  ScreenSharing
  """
  emergency group call
  """
  EmergencyGroupCall
  """
  catch all bucket, treated as default but will be used to detect & identify unknown/new values
  """
  Unknown
}

type CallLogAppContent
  @model(
    tsType: "ICallLogAppContent"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  type: String!
  configId: String
  onBehalfOf: CallLogParticipant
  details: CallLogParticipant
}

type CallLogParticipant {
  id: ID!
  displayName: String
  type: String!
}

enum CallLogCallType {
  MultiParty
  TwoParty
  Unknown
}

enum CallPhoneLineType {
  private
}

enum CallLogCallState {
  Accepted
  AcceptedElsewhere
  Declined
  Missed
  Unknown
}

enum CallDirection {
  Outgoing
  Incoming
  Unknown
}

enum CallLogTransferStatus {
  """
  The transfer has been initiated
  """
  Transferred
  """
  The transfer has been accepted but has not completed
  """
  TransferAccepted
  """
  The transfer has failed
  """
  TransferFailed
  """
  The transfer has succeeded
  """
  TransferSucceeded
  """
  The value is unknown
  """
  Unknown
}

enum CallForwardingType {
  Immediate
  Simultaneous
  Unanswered
}

enum CallForwardingTargetType {
  Voicemail
  SingleTarget
  MyDelegates
  DoNothing
  Group
}

enum BusyOnBusyOptions {
  PlayBusySignal
  RedirectAsUnansweredCall
  RingUser
}

enum RingtoneCallType {
  Regular
  CallQueue
  CallGroup
  Delegate
  MeetingStartedReminder
}

enum RingtoneNames {
  Ring
  Bop
  Bounce
  Bubbles
  DripDrop
  Eureka
  Flutter
  HighScore
  NextLevel
  Plink
  RingRing
  Ripple
  Spacetime
  WishGranted
  Wobble
  BubblesLoud
  Remix
}

input ForwardedMessageContextInput {
  originalSenderMri: String
  originalArrivalTime: String
  originalMessageId: String
  originalMessageContent: String
  originalThreadId: String
}

type ForwardedMessageContext {
  originalSenderMri: String
  originalArrivalTime: String
  originalMessageId: String
  originalMessageContent: String
  originalThreadId: String
}

type CreateFluidShareLinkDriveRecipient {
  email: String
  alias: String
  objectId: String
}

type CreateFluidShareLinkVariables {
  siteUrl: String!
  itemId: String!
  driveId: String!
  queryParams: String!
  linkType: LinkTypeInput!
  scope: LinkScopeInput!
  recipientList: [CreateFluidShareLinkDriveRecipient!]
}

enum FluidUrlPermissionState {
  loading
  granting
}

type FluidUrlProperties {
  url: String
  sourceType: String
}

type FluidUrlPermissionInfo {
  state: FluidUrlPermissionState
  errorCode: String
  grantPermissionVariables: CreateFluidShareLinkVariables
}

type FluidProperties {
  fluidUrlProperties: FluidUrlProperties
}

"""
ONLY ADD TO THIS INTERFACE IF ALL MESSAGES MUST HAVE THE PROPERTY
Represents a message interface. All messages shall inherit from this interface.
Using this to enable the unions on a single type.
Used for normal chat messages, post messages, post reply messages, etc
https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/#:~:text=Interfaces%20are%20a%20powerful%20way,blocks%20for%20creating%20explicit%20types.
"""
interface IMessage {
  id: ID
  content: String
  version: String
  originalArrivalTime: String
  from: ID
  """
  @deprecated(reason: "Use messageRenderType instead to determine UI Rendering for Channels 2.0 and Refactored Chat.")
  """
  messageType: String
  messageRenderType: MessageRenderType
  isImportant: Boolean
  importance: MessageImportance
  emotions: [Emotion!]
  emotionsSummary: [EmotionSummary!]
  mentions: [Mention!]
  cards: [Card!]
  files: [File!]
  deeplinks: [DeepLink!]
  """
  Added to message properties bag when message is deleted
  """
  deleteTime: String
  editTime: String
  hardDeleteReason: String
  hardDeleteTime: String

  """
  Scheduled message information
  """
  scheduledSendTime: String
  draftId: ID

  """
  Forwarded message context information
  """
  forwardedMessageContext: ForwardedMessageContext

  imDisplayName: String
  urlPreview: UrlPreview
  """
  Links in the message
  """
  embeddedLinks: [EmbeddedLink!]
  clientMessageId: ID
  """
  Contains information on whether a user has saved the message
  """
  userHasSaved: Boolean
  dlpContext: DlpContext
  atpSharepointData: [ATPSafelinksSharepointData!]

  status: MessageStatus

  """
  Translation related properties
  """
  translatedSubject: String
  translatedContent: String
  translationStatus: TranslationStatusV2
  isOnDemandTranslation: Boolean
  sourceLanguageName: String
  sourceLanguageCode: String
  isWrittenInPreferredLanguage: Boolean
  languageSeenBefore: Boolean

  """
  Indicates that the message should render the last read line divider.
  """
  isLastRead: Boolean
  """
  Indicates that the message should render the timestamp divider
  """
  isTimestampDividerNeeded: Boolean
  """
  Indicates that the message contains mentions with onBehalfOf property or sent from custom bots
  """
  onBehalfOf: [Mention!]
}

"""
Message is used as the base type for chat messages
"""
type Message implements IMessage {
  id: ID
  subject: String
  content: String
  version: String
  originalArrivalTime: String
  from: ID
  messageType: String
  contentType: String
  isImportant: Boolean
  importance: MessageImportance
  emotions: [Emotion!]
  emotionsSummary: [EmotionSummary!]
  mentions: [Mention!]
  cards: [Card!]
  files: [File!]
  deeplinks: [DeepLink!]
  deleteTime: String
  editTime: String
  imDisplayName: String
  renamedDisplayName: String
  urlPreview: UrlPreview
  embeddedLinks: [EmbeddedLink!]
  clientMessageId: ID
  userHasSaved: Boolean
  dlpContext: DlpContext
  atpSharepointData: [ATPSafelinksSharepointData!]
  fluidUrlPermissionInfo: FluidUrlPermissionInfo
  fluidProperties: FluidProperties
  """
  CUSTOM MESSAGE FIELDS
  """
  onBehalfOf: [Mention!]

  status: MessageStatus
  activityType: String
  containerId: ID
  parentMessageId: ID
  externalId: ID
  callId: ID
  conversationId: String
  announcement: Announcement
  interopDeliveryState: String
  smsDeliveryReports: [SmsDeliveryReport!]
  escalations: [Escalation!]
  isRead: Boolean
  notification: ChatMessageNotification
  notifications: [SurfaceNotification!]
  suggestedActions: SuggestedActions
  messageRenderType: MessageRenderType
  isLastRead: Boolean
  isTimestampDividerNeeded: Boolean
  """
  this field is for call history messages
  """
  callLog: CallLogItem
  type: String
  """
  Permissions for who can reply to this message thread
  """
  replyPermission: MessageReplyPermissions
  meeting: Meeting
  composeTime: String
  isDeletedByAdmin: Boolean
  skypeguid: String
  isCallStartedMessage: Boolean
  hardDeleteReason: String
  hardDeleteTime: String
  scheduledSendTime: String
  softDeleteReason: String
  draftId: ID
  """
  Forwarded message information
  """
  forwardMessageId: ID
  forwardMessageOriginalConvId: String
  forwardMessageRecipients: [String!]
  forwardedMessageContext: ForwardedMessageContext
  """
  Consists of the URL generated when a fluid file is created after the creation of a loop component
  """
  fluidUrl: String

  """
  Translation related properties
  """
  translatedSubject: String
  translatedContent: String
  translationStatus: TranslationStatusV2
  isOnDemandTranslation: Boolean
  sourceLanguageName: String
  sourceLanguageCode: String
  isWrittenInPreferredLanguage: Boolean
  languageSeenBefore: Boolean

  """
  Needed to support channel cross post failure states.
  Note: this should get refactored out of the chat's Message type when
  we split up the send pipeline to have separate ones for chat and channels
  See: Feature 1407384 - Send Message Pipeline improvements - Part 3
  """
  crossPostStatus: ChannelCrossPostStatus
  crossPostFailedChannels: [ID!]

  """
  Viva Topics: Topic annotations for the message
  """
  vivaTopicsAnnotations: VivaTopicsAnnotationResponse
}

type SuggestedActions {
  """
  Actions expected to be taken for the message
  """
  actions: [SuggestedAction!]
  """
  Ids of the recipients that the actions should be shown to
  """
  to: [String!]
}

type SuggestedAction {
  """
  Type of the action (e.g imBack)
  """
  type: String!
  """
  Text description which appears on the button
  """
  title: String!
  """
  Text content value of the action
  """
  value: String!
}

"""
Viva Topics: Interface for the Annotation API response.
Reference from the TS interface: https://dev.azure.com/office/Office/_git/1JS?path=%2Fmidgard%2Fpackages%2Fcortex-topics-types%2Fsrc%2Fmodels%2FAnnotation.ts
"""
type VivaTopicsAnnotationResponse
  @model(
    tsType: "VivaTopicsAnnotationResponse"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  apiVersion: String
  entityAnnotation: VivaTopicsEntityAnnotation
  traceId: String
  clientRequestId: String
}

"EntityDetails: [TopicEntity] is missing as we don't use the entity details in the UX for now"
type VivaTopicsEntityAnnotation {
  sectionMatches: [VivaTopicsSectionMatch]
}

type VivaTopicsSectionMatch {
  entityMatches: [VivaTopicsEntityMatch]
  sectionId: String
}

type VivaTopicsEntityMatch {
  entities: [VivaTopicsEntity]
  highlightedName: String
  length: Int
  startPos: Int
  occurrenceIndex: Int
  totalOccurrences: Int
  relevance: VivaTopicsRelevance
}

type VivaTopicsRelevance {
  annotationScore: Float
}

type VivaTopicsEntity {
  displayName: String
  id: String
  relevanceScore: Float
  source: String
  type: String
}

"""
IMPORTANT: It is important to not treat LastMessage the same as any other
Message. Chat service DOES NOT SEND the entire payload of a Message through
the conversation object's lastMessage field.

Do not assume that the properties bag exist in lastMessage.

This type is intentionally redefined with the same properties as Message in order to
prevent caching issues within Apollo client. The reason is that Conversation.lastMessage
may overwrite the corresponding Message in Apollo cache.
"""
type LastMessage implements IMessage {
  id: ID
  clientMessageId: ID
  draftId: ID
  scheduledSendTime: String
  composeTime: String
  containerId: ID
  content: String
  """
  Forwarded message context information
  """
  forwardedMessageContext: ForwardedMessageContext
  """
  A plain-text version of the `content` meant for inline previewing. For example, in a chat-list item.
  """
  preview: String!
  from: ID
  imDisplayName: String
  renamedDisplayName: String
  messageType: String
  originalArrivalTime: String
  parentMessageId: ID
  type: String
  version: String

  """
  Translation related properties
  """
  translatedSubject: String
  translatedContent: String
  translationStatus: TranslationStatusV2
  isOnDemandTranslation: Boolean
  sourceLanguageName: String
  sourceLanguageCode: String
  isWrittenInPreferredLanguage: Boolean
  languageSeenBefore: Boolean

  """
  Properties below are retained to keep compatibility.

  For example, for conversations which are not fetched from
  Conversation Manager, but from Network, these properties will not
  exist as chat service does not send properties bag in the response.
  """
  activityType: String
  announcement: Announcement
  atpSharepointData: [ATPSafelinksSharepointData!]
  callId: ID
  callLog: CallLogItem
  cards: [Card!]
  contentType: String
  deeplinks: [DeepLink!]
  deleteTime: String
  dlpContext: DlpContext
  editTime: String
  embeddedLinks: [EmbeddedLink!]
  emotions: [Emotion!]
  emotionsSummary: [EmotionSummary!]
  escalations: [Escalation!]
  externalId: ID
  files: [File!]
  formattedArrivalTime: String
  importance: MessageImportance
  interopDeliveryState: String
  isDeletedByAdmin: Boolean
  softDeleteReason: String
  isImportant: Boolean
  isRead: Boolean
  isSystemMessage: Boolean!
  hasMention: Boolean
  canShowEveryoneMentionBadge: Boolean!
  meeting: Meeting
  mentions: [Mention!]
  notification: ChatMessageNotification
  notifications: [SurfaceNotification!]
  onBehalfOf: [Mention!]
  replyPermission: MessageReplyPermissions
  smsDeliveryReports: [SmsDeliveryReport!]
  status: MessageStatus
  subject: String
  urlPreview: UrlPreview
  userHasSaved: Boolean
  suggestedActions: SuggestedActions
  messageRenderType: MessageRenderType
  isLastRead: Boolean
  isTimestampDividerNeeded: Boolean
  hardDeleteReason: String
  hardDeleteTime: String

  """
  Viva Topics: Topic annotations for the message
  """
  vivaTopicsAnnotations: VivaTopicsAnnotationResponse
}

"""
alertInMeeting flag is used to signal incoming notifications in meeting content notification bubbles
externalResourceUrl is used to render hosted web content in meeting content notification bubbble
"""
type ChatMessageNotification {
  alertInMeeting: Boolean
  externalResourceUrl: String
}

type SurfaceNotification {
  surface: String
  contentType: String
  content: SurfaceNotificationContent
  tabEntityId: String
}

type SurfaceNotificationContent {
  value: SurfaceNotificationContentValue
  actions: [CopilotAction]
}

"""
Copilot action is used to render dynamic prompts in meeting copilot
"""
type CopilotAction {
  """
  type of the copilot action e.g. "prompt"
  """
  type: String!
  """
  title of the copilot dynamicSuggestion
  """
  title: String
  """
  value of the copilot dynamicSuggestion
  """
  value: CopilotActionValue
}

"""
Copilot action value is used to render dynamic prompts in meeting copilot
"""
type CopilotActionValue {
  promptText: String
}

type SurfaceNotificationContentValue {
  height: Dimension
  width: Dimension
  title: String
  url: String
}

type EmbeddedLink {
  """
  Href of the anchor tag
  """
  objectUrl: String!
  """
  text of the anchor tag
  """
  title: String
  """
  Description related to the link
  """
  description: String
  """
  File meta deta for the shared file Url
  """
  fileShareUrlMeta: FileShareUrlMeta
}

type FileShareUrlMeta {
  """
  objectUrl of the file
  """
  objectUrl: String
  """
  shareUrl of the file
  """
  shareUrl: String
  """
  fileId of the file
  """
  id: String
  """
  Extension type of a file
  """
  type: String
}

type Announcement {
  title: String!
  """
  Original image from announcement
  """
  originalImageUrl: String
  """
  User-cropped image from announcement
  """
  croppedImageUrl: String
  colorTheme: String
  croppedImageHeight: Float
  croppedImageWidth: Float
  croppedImageAltText: String
  isTeamsIllustration: Boolean
}

type UserFeatureSettingsInfo {
  isPrivateChatEnabled: Boolean
  coExistenceMode: String
}

type UserSkypeTeamsInfo {
  isSkypeTeamsUser: Boolean
}

type CallingScenario {
  name: String!
  clientId: ID!
  scenarioName: String
  status: String
  errorMessage: String
}

type MessageDeletionInfo {
  showMessageAsDeleted: Boolean
  canBeUndeleted: Boolean
  deleteFailed: Boolean
}

"""
An application user. This user holds the source of truth for a user in the graph.
All properties such as name, email etc should always be pulled from this user.
"""
type User {
  id: ID!
  """
  AAD Object ID. Some Users (e.g., bots and PSTN callers) may not have associated AAD object,
  thus this field is nullable.
  """
  objectId: ID
  """
  Thus far, every user has associated Skype MRI. Still, consuming code should be
  prepared to see `null` if things change in future.
  """
  mri: ID
  displayName: String
  email: String
  externalCalendarEmailAddress: String
  givenName: String
  isShortProfile: Boolean
  surname: String
  type: String
  userPrincipalName: String
  department: String
  tenantId: String
  featureSettings: UserFeatureSettingsInfo
  isSipDisabled: Boolean
  jobTitle: String
  mail: String
  mobile: String
  phones: [Phone!]
  physicalDeliveryOfficeName: String
  sipProxyAddress: String
  skypeTeamsInfo: UserSkypeTeamsInfo
  smtpAddresses: [String!]
  telephoneNumber: String
  userLocation: String
  imageUri: String
  accountEnabled: Boolean
  description: String
  isTenantAdmin: Boolean
  privacyStatement: String
  recentActivity: String
  termsOfService: String
  userClassification: String
  userType: String
  """
  profileType comes from MT and is used for MTO / B2BMember profiles at the moment. This will be used more broadly to identify all other types of user.
  """
  profileType: Int
  isUnified: Boolean
  securityEnabled: Boolean
  requestCount: Int
  isIdentityMasked: Boolean
  memberMaskId: ID
  maskedMemberSequenceNumber: String
  """
  User objects coming from the local IndexDB cache (populated when user resolutions happen through TSWeb PeopleService)
  may have isFederated flag
  """
  isFederated: Boolean
  fetchErrorCode: String
  isAnonymousB2bUser: Boolean
  isAnonymousUser: Boolean
  isBlocked: Boolean
  cid: String
  phonesInfo: [UserPhonesInfo]
  emailsInfo: [UserEmailsInfo]
  xtapUser: Boolean
  companyName: String
  tenantName: String
  decoratedDisplayName: String
  """
  Indicates if the information barrier is enabled for the user.
  This is mapped to the ibBarred field in the user object
  """
  isInfoBarrierSet: Boolean

  preferredUserName: String

  """
  Indicates the source of the user when it is created via contact sync flow.
  """
  syncSource: String

  """
  Indicates the email caller used for querying profile.
  Caller can use this field to match profile with email for query when user has
  multiple email aliases that may not be in user's short profile.
  """
  emailForQuery: String

  """
  mri and tenant Id of MTO user for his home tenant
  """
  homeMri: String
  homeTenantId: String
  selfAvatarLastupdatedTime: String
  isCcmUser: Boolean
}

type MeetingAgenda {
  type: MeetingAgendaType
  location: String
  shareLink: String
  metadata: MeetingAgendaMetadata
}

input MeetingAgendaInput {
  type: MeetingAgendaType
  location: String
  shareLink: String
  metadata: MeetingAgendaMetadataInput
}

type MeetingAgendaMetadata {
  state: MeetingAgendaState
  isShared: Boolean
  linkScope: String
  hostClient: MeetingAgendaHostClient
}

input MeetingAgendaMetadataInput {
  state: MeetingAgendaState
  isShared: Boolean
  linkScope: String
  hostClient: MeetingAgendaHostClient
}

enum MeetingAgendaHostClient {
  TeamsInMeeting
  TeamsCalendarDetailsPage
  TeamsCalendarScheduling
}

enum MailboxType {
  Personal
  Group
}

enum MeetingAgendaType {
  collaborativeSpace
}

enum MeetingAgendaState {
  Disabled
  Enabled
}

type EventActiveStatus {
  isActive: Boolean
}

type RightsManagementLicenseData {
  rmsTemplateId: ID
  templateName: String
  templateDescription: String
  editAllowed: Boolean
  replyAllowed: Boolean
  replyAllAllowed: Boolean
  forwardAllowed: Boolean
  modifyRecipientsAllowed: Boolean
  extractAllowed: Boolean
  printAllowed: Boolean
  exportAllowed: Boolean
  programmaticAccessAllowed: Boolean
  isOwner: Boolean
  contentOwner: String
  contentExpiryDate: String
  rightsManagedMessageDecryptionStatus: Int
  bodyType: String
}

enum CalendarErrorCode {
  ApplicationThrottled
  CalendarEventCreationFailedInExchange
  CalendarEventCreationFailedOccurrenceTimeSpanTooBig
  CalendarEventEndDateIsEarlierThanStartDate
  CalendarEventNotFound
  CalendarEventNull
  ConnectedAccountNotFound
  EmptySchedulingServiceEvent
  EmptySchedulingServiceMeetingSettings
  ErrorCalendarEndDateIsEarlierThanStartDate
  ErrorCalendarIsCancelledForAccept
  ErrorCalendarIsCancelledForDecline
  ErrorCalendarIsCancelledForRsvp
  ErrorCalendarIsCancelledForTentative
  ErrorCalendarIsNotOrganizer
  ErrorCalendarIsOrganizerForAccept
  ErrorCalendarIsOrganizerForDecline
  ErrorCalendarIsOrganizerForRsvp
  ErrorCalendarIsOrganizerForTentative
  ErrorInSchedulingServiceEventNotFound
  ErrorInSchedulingServiceMsnpMeetingPropertiesNotFound
  ErrorInSchedulingServiceNotInEventTeam
  ErrorInSchedulingServiceOutdatedEvent
  ErrorInvalidLicense
  ErrorInvalidRecipients
  ErrorItemNotFound
  ErrorNonExistentMailbox
  ErrorOccurrenceCrossingBoundary
  ErrorOccurrenceTimeSpanTooBig
  ErrorQuotaExceeded
  ErrorRecurrenceHasNoOccurrence
  ErrorTimeZone
  ExchangeInvalidLicense
  HtmlViewNotPresent
  InvalidCancellationMessageFormat
  InvalidConversationId
  InvalidExchangeId
  InvalidICalUid
  InvalidMailboxAddress
  InvalidMailboxAddressOrGuid
  InvalidMeetingOrganizer
  InvalidUpdateMessageFormat
  NetworkError
  NetworkOffline
  QuotaExceeded
  ShadowMailboxDeleted
  ShadowTokenExpired
  ShadowTokenRevoked
  StartDateGreaterThanEndDateValidationError
  Unknown
  ValidationError
}

type CalendarErrorResponse {
  originalErrorMessage: String
  originalCode: String
  message: String!
  statusCode: Int
  code: CalendarErrorCode!
  requestId: String
  isExpected: Boolean!
  type: String!
}

type CalendarEvent {
  objectId: ID!
  objectUrl: String
  startTime: ScalarEnumString!
  endTime: ScalarEnumString!
  eventTimeZone: ScalarEnumString
  utcOffset: Float
  iCalUID: String
  eventType: AppointmentType
  subject: String
  location: String
  skypeTeamsData: String
  skypeTeamsDataObj: SkypeTeamsData
  schedulingServiceUpdateUrl: String
  skypeTeamsMeetingUrl: String
  isOnlineMeeting: Boolean
  inviteAllMembers: Boolean
  joinOnlineMeetingUrl: String
  joinMeetingLabel: String
  emptyBodyPlaceholder: String
  myResponseType: MeetingResponseType
  myAttendance: MeetingAttendanceType
  isAllDayEvent: Boolean
  organizerName: String
  organizerAddress: String
  categories: [String!]
  isCancelled: Boolean
  isResponseRequested: Boolean
  attendees: [Attendee!]
  isReminderSet: Boolean
  reminderMinutesBeforeStart: Int
  mailboxAddress: String
  mailboxType: MailboxType
  threadId: String
  showAs: FreeBusyType
  isPrivate: Boolean
  bodyContentType: String
  bodyContent: String
  bodyPreview: String
  recurrencePattern: String
  recurrenceEnd: String
  isOrganizer: Boolean
  parentConversationId: String
  isAppointment: Boolean
  eventRecurrenceRange: RecurrenceRange
  eventRecurrencePattern: RecurrencePattern
  reminderTime: String
  attachments: [Attachment!]
  hasAttachments: Boolean
  conflictingMeetings: [CalendarEvent!]
  broadcastSettings: BroadcastSettings
  putAnonymousInLobby: Boolean
  eTag: String
  state: MeetingStatus
  cleanGlobalObjectId: String
  seriesMasterId: String
  primarySpokenLanguage: String
  clientOptimisticEventId: String
  isOptimisticEvent: Boolean
  doNotForward: Boolean
  webinarRegistration: WebinarRegistrationInfo
  meetingAgenda: String
  meetingAgendaObj: MeetingAgenda
  meetingTemplateId: String
  contextId: String
  inviteesWithMeetingRole: [Attendee!]
  activeStatus: EventActiveStatus
  virtualEventsData: VirtualEventsData
  virtualAppointmentInfo: VirtualAppointmentInfo
  actionType: EventActionType
  rightsManagementLicenseData: RightsManagementLicenseData
  sensitivityLabelId: String
  previousSensitivityLabelId: String
  lastModifiedTime: ScalarEnumString
  meetingArtifactsCollaborationData: MeetingCollaboration
  downgradeLabelJustification: String
  containsFollowers: Boolean
  coverImage: String
  coverImageReference: String
  originalGroupChatThreadId: String
}

type MeetingCollaboration {
  id: ID!
  participants: [MeetingArtifactsParticipant!]!
  resources: [MeetingArtifactResource!]!
}

type MeetingArtifactsParticipant {
  id: ID!
  name: String
  roles: [String!]!
}

type MeetingArtifactResource {
  id: ID!
  type: MeetingArtifactResourceType!
  location: String
  metadata: MeetingArtifactMetadata
}

enum MeetingArtifactResourceType {
  Recording
  Notes
  AttendanceReport
  Transcript
  SuggestedTasksSession
  MeetingContent
  Document
  PowerPoint
  Whiteboard
  Attachments
  MeetingStage
  MeetingChat
  Attachment
}

type MeetingArtifactMetadata {
  callId: ID
  groupId: ID
  messageId: ID
  organizerId: ID
  threadId: ID
}

enum LeftRailSettingsCalendarType {
  Channel
}

type CalendarLeftRailSettingsData {
  """
  Calendar type enum to represent channel, private, shared, group, etc
  """
  calendarType: LeftRailSettingsCalendarType
  """
  whether it is selected/checked in the left rail
  """
  isSelected: Boolean
  """
  order of the selected calendar
  """
  sequenceNumber: Int
  """
  thread id of the calendar, instead of channel name saving thread id since channel name is mutable
  """
  threadId: String
}

input CalendarLeftRailSettingsDataInput {
  calendarType: LeftRailSettingsCalendarType
  isSelected: Boolean
  sequenceNumber: Int
  threadId: String
}

type CalendarMailboxAddressesData {
  """
  thread id of the calendar, instead of channel name saving thread id since channel name is mutable
  """
  threadId: String
  """
  mailboxAddress of the channel
  """
  mailboxAddress: String
}

input CalendarMailboxAddressesInput {
  threadId: String
  mailboxAddress: String
}

input CalendarLeftRailSettingsInput {
  id: ID!
  eTag: String
  settings: [CalendarLeftRailSettingsDataInput]
  mailboxAddresses: [CalendarMailboxAddressesInput]
}

type CalendarLeftRailSettings {
  id: ID!
  eTag: String
  settings: [CalendarLeftRailSettingsData]
  mailboxAddresses: [CalendarMailboxAddressesData]
}

input CalendarSettingsInput {
  id: ID!
  dateRangeType: ViewMode!
}

type CalendarSettings {
  id: ID!
  dateRangeType: ViewMode!
}

enum ViewMode {
  Agenda
  WorkWeek
  Week
  Day
}

enum CoverImageAction {
  Update
  Delete
  NoChange
}

input ImportCalendarEventInput {
  iCalUid: String!
  conversationId: String
  meetingTitle: String
  joinUrl: String
  location: String
  rsvpTo: String
  organizerDisplayName: String
  body: String
  startTime: ScalarEnumString!
  endTime: ScalarEnumString
  isCancelled: Boolean
  eventRecurrenceRange: RecurrenceRangeInput
  eventRecurrencePattern: RecurrencePatternInput
  connectedAccountId: String
  connectedAccountAddress: String
  timeZoneId: String
  attendeeEmailAddress: String
  attendeeDisplayName: String
  skipConnectedAccountLookup: Boolean
  eventType: AppointmentType
  originalStartTime: ScalarEnumString
}

input CalendarEventInput {
  objectId: ID
  objectUrl: String
  startTime: ScalarEnumString!
  endTime: ScalarEnumString!
  eventTimeZone: ScalarEnumString
  utcOffset: Float
  iCalUID: String
  cleanGlobalObjectId: String
  eventType: AppointmentType
  subject: String
  location: String
  skypeTeamsData: String
  skypeTeamsDataObj: SkypeTeamsDataInput
  schedulingServiceUpdateUrl: String
  skypeTeamsMeetingUrl: String
  isOnlineMeeting: Boolean
  inviteAllMembers: Boolean
  joinOnlineMeetingUrl: String
  joinMeetingLabel: String
  emptyBodyPlaceholder: String
  myResponseType: MeetingResponseType
  myAttendance: MeetingAttendanceType
  isAllDayEvent: Boolean
  isOnlineTeamsMeeting: Boolean
  organizerName: String
  organizerAddress: String
  categories: [String!]
  isCancelled: Boolean
  isResponseRequested: Boolean
  attendees: [AttendeeInput!] = []
  isReminderSet: Boolean
  reminderMinutesBeforeStart: Int
  mailboxAddress: String
  showAs: FreeBusyType = Busy
  isPrivate: Boolean
  bodyContentType: String
  bodyContent: String
  bodyPreview: String
  recurrencePattern: String
  recurrenceEnd: String
  isOrganizer: Boolean
  parentConversationId: String
  isAppointment: Boolean
  eventRecurrenceRange: RecurrenceRangeInput
  eventRecurrencePattern: RecurrencePatternInput
  reminderTime: String
  attachments: [AttachmentInput!]
  hasAttachments: Boolean
  conflictingMeetings: [CalendarEventInput!]
  broadcastSettings: BroadcastSettingsInput
  putAnonymousInLobby: Boolean
  eTag: String
  primarySpokenLanguage: String
  contextId: String
  """
  following fields are added to enable prefetching(preload)
  """
  lastModifiedTime: ScalarEnumString
  onlineMeetingConfLink: ScalarEnumString
  onlineMeetingConferenceId: ScalarEnumString
  onlineMeetingTollFreeNumbers: [ScalarEnumString]
  onlineMeetingTollNumber: ScalarEnumString
  teamsVtcTenantId: ScalarEnumString
  teamsVtcConferenceId: String
  isBroadcastEvent: Boolean
  isBroadcastMeeting: Boolean
  clientOptimisticEventId: String
  isOptimisticEvent: Boolean
  doNotForward: Boolean
  webinarRegistration: WebinarRegistrationInfoInput
  seriesMasterId: String
  meetingAgenda: String
  meetingAgendaObj: MeetingAgendaInput
  meetingTemplateId: String
  sensitivityLabelId: String
  previousSensitivityLabelId: String
  virtualAppointmentInfo: VirtualAppointmentInfoInput
  downgradeLabelJustification: String
  coverImage: String
  coverImageReference: String
  coverImageAction: CoverImageAction
  originalGroupChatThreadId: ID
}

input PatchCalendarEventInput {
  objectId: ID
  meetingAgenda: String!
}

enum AppointmentType {
  Single
  Occurrence
  Exception
  RecurringMaster
}

enum AttendeeType {
  Required
  Optional
  Resource
  Organizer
  Room
}

enum AttendeeGroupType {
  StreamGroup
  SecurityGroup
}

enum BroadcastMeetingAccessLevel {
  Anonymous
  AllCompany
  InvitationOnly
}

enum FreeBusyType {
  Free
  Tentative
  Busy
  Oof
  WorkingElsewhere
  Unknown
}

enum MeetingResponseType {
  None
  Organizer
  Tentative
  Accepted
  Declined
  NotResponded
}

enum MeetingAttendanceType {
  None
  InPerson
  Virtual
  Follow
  UnknownFutureValue
}

enum MeetingStatus {
  Created
  Activated
  Abandoned
  Suspended
  Live
  Stopped
  Deleted
  Recreated
  Hidden
}

enum PhoneType {
  Mobile
  Business
  Home
  Pager
  Organization
  HomeFax
  BusinessFax
  Other
  Unknown
  Assistant
  OtherFax
  Radio
}

enum EventActionType {
  Delete
}

type Phone {
  number: String!
  type: PhoneType!
  normalizedNumber: String
  displayString: String
  isValid: Boolean
}

type UserPhonesInfo {
  number: String
  country: String
  nationalNumber: String
  searchable: Boolean
  visibility: String
}

type UserEmailsInfo {
  address: String
  searchable: Boolean
  visibility: String
}

type Attendee {
  status: ResponseStatus
  type: AttendeeType
  address: String
  name: String
  jobTitle: String
  mri: String
  role: String
  broadcastMeetingRole: String
  groupType: AttendeeGroupType
  isGroup: Boolean
  objectId: String
  upn: String
  meetingRole: String
}

type BroadcastSettings {
  isStreamEnabled: Boolean
  isRecordingEnabled: Boolean
  isVodEnabled: Boolean
  isAttendeeReportDisabled: Boolean
  isQAndAEnabled: Boolean
  accessLevel: BroadcastMeetingAccessLevel
  transcriptionSettings: BroadcastTranscriptionSettings
  yammerSettings: BroadcastYammerSettings
  troubleshootingSettings: BroadcastTSSettings
  customLinkSettings: BroadcastCustomLinkSettings
  broadcastAttendees: [Attendee!]
  broadcastETMs: [BroadcastETM!]
  modalityLinks: MeetingModalityLink
  userRole: String
  organizerMeetingRole: String
}

type BroadcastCustomLinkSettings {
  url: String
  text: String
}

type BroadcastETM {
  mri: String
  broadcastMeetingRole: String
}

type BroadcastTranscriptionSettings {
  transcription: Boolean
  translationCultureNames: [String!]
}

type BroadcastTSSettings {
  link: String
}

type BroadcastYammerSettings {
  isEnabled: Boolean
  groupId: String
  promptText: String
  groupName: String
}

type MeetingModalityLink {
  attendee: String
  attendeeSupport: String
  qnaAttendee: String
  qnaModerator: String
  yammer: MeetingModalityYammer
  stream: MeetingModalityStream
}

type MeetingModalityStream {
  published: Boolean
  videoId: String
  ingestUrls: [StreamIngestUrl!]
  producerEmbed: String
  attendeeEmbed: String
  analyticsEmbed: String
  addVideoToGroup: Boolean
}

type MeetingModalityYammer {
  broadcastId: String
  groupId: String
  published: Boolean
  event: String
}

type StreamIngestUrl {
  url: String
  protocol: String
  type: String
}

type SkypeTeamsData {
  cid: String
  rid: ID
  mid: ID
  uid: String
  private: Boolean
  type: Int
}

type VirtualEventsData {
  eventId: String
  eventUrl: String
  sessionId: String
}

type VirtualAppointmentInfo {
  appointmentId: String
  settings: VirtualAppointmentSettings
  appointmentClients: [VirtualAppointmentClient]
  eTag: String
}

type VirtualAppointmentSettings {
  allowClientToJoinUsingBrowser: Boolean!
  notifications: [String]
}

type VirtualAppointmentClient {
  displayName: String!
  emailAddress: String!
  smsCapablePhoneNumber: String
  smsCountryCode: String
}

input VirtualAppointmentInfoInput {
  appointmentId: String
  settings: VirtualAppointmentSettingsInput
  appointmentClients: [VirtualAppointmentClientInput]
  eTag: String
}

input VirtualAppointmentSettingsInput {
  allowClientToJoinUsingBrowser: Boolean!
  notifications: [String]
}

input VirtualAppointmentClientInput {
  displayName: String!
  emailAddress: String!
  smsCapablePhoneNumber: String
  smsCountryCode: String
}

type ResponseStatus {
  attendance: MeetingAttendanceType
  response: String
  time: String
}

enum AttachmentType {
  ItemAttachment
  FileAttachment
  ReferenceAttachment
}

type Attachment {
  id: String!
  name: String
  size: Int!
  contentType: String
  fileName: String
  isInline: Boolean
  contentId: String
  attachmentType: AttachmentType!
  attachLongPathName: String
  providerType: String
  providerEndpointUrl: String
}

type RecurrenceRange {
  startDate: ScalarEnumString!
  endDate: ScalarEnumString
}

type RecurrencePattern {
  patternType: ScalarEnumString!
  daily: DailyPattern
  weekly: WeeklyPattern
  monthly: MonthlyPattern
  relativeMonthly: RelativeMonthlyPattern
  yearly: YearlyPattern
  relativeYearly: RelativeYearlyPattern
}

type DailyPattern {
  interval: Int!
}

type WeeklyPattern {
  daysOfTheWeek: [ScalarEnumString!]!
  interval: Int!
}

type MonthlyPattern {
  dayOfMonth: Int!
  interval: Int!
}

type RelativeMonthlyPattern {
  dayOfTheWeekIndex: ScalarEnumString!
  dayOfTheWeek: ScalarEnumString!
  interval: Int!
}

type YearlyPattern {
  month: ScalarEnumString!
  dayOfTheMonth: Int!
}

type RelativeYearlyPattern {
  month: ScalarEnumString!
  dayOfTheWeekIndex: ScalarEnumString!
  dayOfTheWeek: ScalarEnumString!
}

enum TeamType {
  Team
  Edu
  Class
  Plc
  Staff
  HealthcareCareCoordination
  Community
}

enum TeamAccessType {
  None
  Private
  Secret
  Public
  HiddenMembership
  Unknown
  All
}

enum ChannelType {
  Standard
  Private
  Shared
}

enum ChannelArchivalLevel {
  none
  space
  topic
}

type SensitivityLabelActionSummary {
  name: String!
  isCopyRestrictionEnforced: Boolean!
  privacy: String
  isChannelSharedWithExternalTenants: Boolean!
  isChannelSharedWithSameLabelOnly: Boolean!
}

type SensitivityLabelPolicySettings {
  id: ID!
  isMandatory: Boolean
  helpWebUrl: String
  downgradeSensitivityRequiresJustification: Boolean
}

type SensitivityLabelDefaultContentLabel {
  id: ID!
  isCopyBlocked: Boolean
}

type SensitivityLabelConversation {
  id: ID!
  name: String
  applicableTo: String
  displayName: String
  parentId: String
  parentName: String
  parentDisplayName: String
  parentToolTip: String
  toolTip: String
  isCopyBlocked: Boolean
  isUserScoped: Boolean
  priority: Int
  isDefault: Boolean
  labelActions: [SensitivityLabelActionSummary!]
  defaultContentLabel: SensitivityLabelDefaultContentLabel
}

enum TeamLockState {
  Locked
  PartialSuccess
  Failed
  Unlocked
}

interface BaseTeam {
  id: ID!
  displayName: String!
  isDeleted: Boolean!
  pictureETag: String
  memberRole: TeamMemberRole!
  teamSiteInformation: TeamSiteInformation!
  teamSettings: TeamSettings!
  tenantId: String
}

union TeamUnion = Team | NonMemberSharedTeam

type NonMemberSharedTeam implements BaseTeam {
  id: ID!
  displayName: String!
  description: String
  isDeleted: Boolean!
  pictureETag: String
  memberRole: TeamMemberRole!
  teamSiteInformation: TeamSiteInformation!
  teamSettings: TeamSettings!
  tenantId: String
}

type Team implements BaseTeam
  @model(
    tsType: "TeamModel"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  channelOnlyMember: Boolean
  channels: [Channel!]!
  classification: String
  description: String
  displayName: String!
  dynamicMembership: Boolean
  groupInformation: GroupInformation
  hasNewHiddenChannels: Boolean
  hiddenChannelsCount: Int
  id: ID!
  isArchived: Boolean
  isCollapsed: Boolean
  isDeleted: Boolean!

  isExternal: Boolean
  isDiscoverable: Boolean
  isExpanded: Boolean
  isFavorite: Boolean
  isGeneralChannelFavorite: Boolean
  teamLockState: TeamLockState
  """
  deprecated in favor of isNewForUser, will be removed in ADO #2123175
  """
  isNew: Boolean
  isNewForUser: Boolean
  isUserMuted: Boolean
  isTenantWide: Boolean
  isUserMember: Boolean
  joinCode: String
  membershipSummary: MembershipSummary
  memberRole: TeamMemberRole!
  order: Int
  pictureETag: String
  sensitivityLabel: SensitivityLabelConversation
  smtpAddress: String
  teamGuestSettings: TeamSettings
  teamSettings: TeamSettings!
  teamSiteInformation: TeamSiteInformation!
  teamType: TeamType
  tenantId: String
  thumbnailUri: String
  totalActivityCount: Int
  totalUnreadCount: Int
  visibility: TeamAccessType
  hasChannelMention: Boolean
  hasTeamMention: Boolean
  lastJoinAt: String
  sharedChannelsFromOtherTeamsConnection: SharedChannelsFromOtherTeamsConnection
  defaultTeamInitialsPicture: String
  shouldShowHideTeamOnChannelShowHide: Boolean
}

type SharedChannelsFromOtherTeamsConnectionEdge {
  cursor: String
  node: Channel!
}

type SharedChannelsFromOtherTeamsConnection {
  pageInfo: PageInfo!
  edges: [SharedChannelsFromOtherTeamsConnectionEdge!]
}

type MembershipSummary {
  memberCount: Int!
  externalMemberCount: Int
  explicitlyAddedUserCount: Int
  botCount: Int!
  readerCount: Int!
  adminCount: Int!
  userCount: Int!
  guestCount: Int!
  sharedWithTeamsCount: Int
}

type TeamSiteInformation {
  groupId: String
  sharepointSiteUrl: String
}

enum TeamMemberRole {
  Undefined
  User
  Admin
  Guest
  Shadow
}

type TeamSettings {
  generalChannelPosting: GeneralChannelPosting
  mentions: TeamMentionSettings
  funControl: TeamFunControlSettings
  editMessagesEnabled: Boolean
  deleteMessagesEnabled: Boolean
  adminDeleteEnabled: Boolean
  installAndUninstallApps: Boolean
  uploadCustomApp: Boolean
  createAndDeleteTab: Boolean
  createAndUpdateChannel: Boolean
  deleteChannel: Boolean
  createPrivateChannel: Boolean
  updateConnectors: Boolean
  addAndRemoveDisplayContent: Boolean
}

type GroupInformation {
  groupExpiryTime: String
  isEligibleForRenewal: Boolean
}

type TeamMentionSettings {
  teamMention: Boolean!
  channelMention: Boolean!
}

enum GiphyRatingType {
  Strict
  Moderate
  NoRestriction
}

type TeamFunControlSettings {
  giphyEnabled: Boolean!
  """
  include stickers and static memes
  """
  stickersEnabled: Boolean!
  giphyRating: GiphyRatingType!
  customMemesEnabled: Boolean!
  teamMemesEnabled: Boolean
}

enum GeneralChannelPosting {
  AnyonePost
  AnyoneWithWarning
  OwnersPost
}

enum CommunityMemberRoleUpdateType {
  Promoted
  Demoted
}

type CommunityJoinRequest {
  userMri: String!
  name: String
  resultCode: String
  errorStatusCode: Int
  errorSubCode: Int
}

type CommunityMemberBlocked {
  mri: String!
  resultCode: String!
  state: String
  error: String
}

type CommunityRosterSummary {
  adminCount: Int!
  botCount: Int!
  userCount: Int!
}

enum CommunityJoinRequestsActionType {
  Accept
  Decline
}

type CommunitiesJoinInformation {
  shareJoinLink: Boolean
  joiningenabled: Boolean
}

type CommunitiesAppConfig {
  baseImageUrl: String
}

type Communities {
  id: ID!
  displayName: String
  """
  The below shareJoinLink field would be removed after the cdl upgrade.
  """
  shareJoinLink: Boolean
  description: String
  profilePictureUrl: String
  memberCount: Int
  unreadPostsCount: Int
  isCurrentUserAdmin: Boolean
  teamId: ID
  joinRequests: [CommunityJoinRequest!]
  rosterSummary: CommunityRosterSummary
  groupId: String
  joinInformation: CommunitiesJoinInformation
  notificationSettings: PerCommunityNotificationSettings
  membersBlocked: [CommunityMemberBlocked]
  isDeleted: Boolean
  isUserMember: Boolean
}

type SubCommunities {
  avatarUrl: String
}

enum PerCommunityNotificationSettings {
  AllActivity
  OnlyNewPosts
  Off
}

interface BaseChannel {
  id: ID!
  createdAt: String
  displayName: String!
  channelType: ChannelType
  isDeleted: Boolean
  isGeneral: Boolean
  isShown: Boolean
  memberRole: TeamMemberRole
  teamV2: TeamUnion
}

type DeletedChannel implements BaseChannel
  @model(
    tsType: "DeletedChannelModel"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  id: ID!
  createdAt: String!
  deleteTime: String!
  displayName: String!
  channelType: ChannelType!
  isDeleted: Boolean!
  isGeneral: Boolean!
  isShown: Boolean!
  memberRole: TeamMemberRole
  teamV2: TeamUnion
}

type NonMemberChannel implements BaseChannel
  @model(
    tsType: "NonMemberChannelModel"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  id: ID!
  createdAt: String!
  lastMessageArrivalTime: String
  displayName: String!
  channelType: ChannelType!
  isDeleted: Boolean!
  isGeneral: Boolean!
  isShown: Boolean!
  isUserMember: Boolean!
  memberRole: TeamMemberRole
  hostTeamId: String
  substrateGroupId: String
  teamV2: TeamUnion
}

type Channel implements BaseChannel
  @model(
    tsType: "ChannelModelClass"
    from: "@msteams/data-resolver-types"
    scope: SERVER_RESOLVERS
  ) {
  activeCallCount: Int
  activityCount: Int
  archivalLevel: ChannelArchivalLevel
  channelType: ChannelType
  consumptionHorizon: ConsumptionHorizon
  consumptionHorizonBookmark: ConsumptionHorizonBookmark
  createdAt: String
  displayName: String!
  description: String
  defaultFileSettings: DefaultFileSettings
  emailInformation: ChannelEmailInformation
  explicitlyAdded: Boolean
  hasImportantNotification: Boolean
  hostTeamId: String
  hostTenantId: String
  hostTeamGroupId: String
  id: ID!
  isArchived: Boolean
  isBackedBySubstrateGroup: Boolean
  isDeleted: Boolean
  """
  Indicates if this channel is itself external
  """
  isExternal: Boolean
  """
  Indicates if the channel is shared with an external team or user
  """
  isChannelExternallyShared: Boolean
  isGeneral: Boolean!
  isNew: Boolean
  isPinned: Boolean
  lastMessageArrivalTime: String
  lastMessage: LastMessage
  pinnedOrder: Int
  pinnedVersion: Int
  isShown: Boolean!
  isShownByDefault: Boolean
  parentTeamId: String
  isFollowed: Boolean
  notificationSettings: ChannelNotificationSettingsResponse
  """
  for private and shared channel which has same space type and treated like a team
  """
  memberRole: TeamMemberRole
  membershipSummary: MembershipSummary
  channelSettings: ChannelSettings
  isModerator: Boolean
  sharepointSiteUrl: String
  substrateGroupId: String
  channelResourceTenantId: String
  tabs: [Tab!]
  team: Team
  owningTeam: Team
  hasBookmark: Boolean
  unreadMessageCount: Int
  sensitivityLabel: SensitivityLabelConversation
  """
  private and shared channels have space type and space admin settings
  """
  spaceAdminSettings: SpaceAdminSettings
  classification: String
  hasChannelMention: Boolean
  hasTeamMention: Boolean
  isNewForUser: Boolean
  isUserMember: Boolean
  isShared: Boolean
  isSharedAtCreation: Boolean
  callQueueId: String
  """
  Marks if the channel is a lie. This is currently used by shared channel creation lie.
  """
  isLie: Boolean
  """
  Real thread id for the lie channel when lie is resolved.
  """
  realThreadId: String
  """
  Indicating if channel async creation has failed. This is currently used by shared channel creation lie.
  """
  isCreationFailed: Boolean
  """
  params filter, first and after will move removed and input will be used once channel-info-pane switches to input
  """
  membersConnection(
    filter: String
    first: Int
    after: String
    input: ChannelMembersConnectionInput
  ): ChannelMembersConnection
  channelEmailSettings: ChannelEmailSettings
  defaultOneNoteSectionId: String
  deleteTime: String
  teamV2: TeamUnion
}

input ChannelMembersConnectionInput {
  filter: ChannelMembersConnectionFilter
  first: Int
  after: String
}

input ChannelMembersConnectionFilter {
  recentContributors: Boolean
  membershipFromTeam: ID
}

type ChannelNotificationSettingsResponse {
  settings: ChannelNotificationSettings!
  defaults: ChannelNotificationSettings!
}

type ChannelNotificationSettings {
  allNewPosts: String!
  includeReplies: Boolean!
  channelMentions: String!
}

union ChannelEmailSettings =
    ChannelEmailSettingsSuccess
  | ChannelEmailSettingsError

type ChannelEmailSettingsSuccess {
  allowedSenders: AllowedChannelEmailSenders!
  emailAddressDetails: ChannelEmailAddressDetails!
}

type ChannelEmailSettingsError {
  errorCode: String
}

type ChannelEmailAddressDetails {
  emailId: String!
}

type AllowedChannelEmailSenders {
  allowedSenderType: String!
  allowedDomains: [String!]
}

type ChannelMembersConnectionEdge {
  cursor: String
  # role of the node specific to this edge
  role: TeamMemberRole
  # whether the node is explicitly added to this channel
  explicitlyAdded: Boolean
  conversationId: String
  node: User!
}

type ChannelMembersConnection {
  pageInfo: PageInfo!
  edges: [ChannelMembersConnectionEdge!]
}

type ChannelSystemMessagesConnectionEdge {
  cursor: String
  node: ChannelSystemMessageType!
}

type ChannelSystemMessagesConnection {
  pageInfo: PageInfo!
  edges: [ChannelSystemMessagesConnectionEdge!]
}

interface ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
}

# Data model structure for system messages [MeetingPolicyUpdated, ThreadShared]
type BaseChannelSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
}

# Data model structure for system messages [DeleteMember, AddMember]
type AddDeleteMemberSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  members: [User]
  initiatorType: String
  isSharedChannel: Boolean
  hostTenantId: String
  hostConversationId: String
  originalMembersCount: Int
}

enum PinnedPostContentType {
  Text
  VoiceMessage
  CodeSnippetCard
  Card
  File
  GiphyMessage
  ImageMessage
}

type PinnedPostSummary implements IEdgeNode {
  id: ID!
  conversationId: String
  replyChainId: String!
  postType: PostType!
  from: User
  postTitle: String
  contentType: PinnedPostContentType
  originalArrivalTime: String
  creationTime: String
  updatedTime: String
}

# Data model structure for system messages [TopicDescriptionUpdated, SpaceDescriptionUpdated, SpaceTopicUpdated, TopicTopicUpdated, TopicDeleted, TopicUpdated]
type ChannelUpdatesSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  oldValue: String
  newValue: String
  initiatorType: String
}

enum PinOperation {
  Pinned
  Unpinned
}

# Data model structure for system messages [PinnedItemsUpdated]
type PinnedItemSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  operation: PinOperation
}

# Data model structure for system messages [MemberLeft, MemberJoined]
type ManageMembersSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  members: [User]
  isTemporary: Boolean
}

# Data model structure for system messages [SpaceThreadChannelAdded, SpaceThreadChannelDeleted]
type ChannelAddDeleteSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  channels: [Channel]
  isInitiatedByXTAP: Boolean
  oldValue: String
  newValue: String
}

# Data model structure for system messages [SharedInSpacesUpdated]
type SharedInSpacesSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  team: Team
  isInitiatedByXTAP: Boolean
  oldValue: String
  newValue: String
}

enum ChannelSystemMessageRoleUpdateType {
  RoleUpdatePromotion
  SystemRoleUpdatePromotion
  RoleUpdateDemotion
  SystemRoleUpdateDemotion
}

# Data model structure for system messages [RoleUpdate]
type RoleUpdateSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  roleUpdateType: ChannelSystemMessageRoleUpdateType
  member: User
}

# Data model structure for system messages [UpdateFavDefault]
type UpdateFavDefaultSystemMessage implements ChannelSystemMessage {
  id: ID!
  conversationId: String
  content: String
  messageType: String
  composeTime: String
  originalArrivalTime: String
  initiator: User
  # CUSTOM PROPERTIES
  isDefault: Boolean
}

union ChannelSystemMessageType =
    BaseChannelSystemMessage
  | AddDeleteMemberSystemMessage
  | ChannelUpdatesSystemMessage
  | PinnedItemSystemMessage
  | ManageMembersSystemMessage
  | ChannelAddDeleteSystemMessage
  | SharedInSpacesSystemMessage
  | RoleUpdateSystemMessage
  | UpdateFavDefaultSystemMessage

enum ChannelPostPermissions {
  Everyone
  Moderators
  EveryoneButGuests
}

enum ChannelReplyPermissions {
  Everyone
  Moderators
}

enum ChannelPinPostPermissions {
  Everyone
  Moderators
}

type ChannelSettings {
  channelPostPermissions: ChannelPostPermissions
  allowReplies: ChannelReplyPermissions
  allowPinPosts: ChannelPinPostPermissions
  allowBotsPost: Boolean
  allowConnectorsPost: Boolean
}

type SpaceAdminSettings {
  userSettings: TeamSettings
  guestSettings: TeamSettings
}

type ChannelEmailInformation {
  emailAddress: String!
  allowedSenders: AllowedEmailSenders!
}

type AllowedEmailSenders {
  senderType: AllowedSenderType!
  allowedDomains: [String!]
}

enum AllowedSenderType {
  Domains
  Members
  Anyone
}

type DefaultFileSettings {
  filesRelativePath: String
}

type Tab {
  id: ID!
  definitionId: String
  settings: Settings
  name: String
}

type Settings {
  subtype: String
  name: String
  websiteUrl: String
  url: String
}

type UrlPreview {
  url: String!
  title: String
  description: String
  previewEnabled: Boolean
  thumbnail: String
  thumbnailMeta: ImageMeta
}

type RichUrlPreviewResult {
  id: ID!
  card: Card
  urlPreview: UrlPreview
}

type DlpContext {
  policyViolation: PolicyViolation
  dlpData: DlpData
}

type Meeting {
  itemId: ID
  meetingTitle: String
  """
  Abstraction for Chat's meeting thread property's @type field
  @type contains http://schema.skype.com/ScheduledMeetingCreated/ ScheduledMeetingUpdated / ScheduledMeetingCancelled
  """
  meetingActionType: String
  tenantId: String
  organizerId: String
  meetingJoinUrl: String
  location: String
  body: String
  rsvpTo: String
  scheduledMeetingInfo: ScheduledMeetingInfo
}

input MeetingInput {
  itemId: ID!
  meetingTitle: String
  meetingActionType: String
  tenantId: String!
  organizerId: String!
  meetingJoinUrl: String
  location: String
  body: String
  rsvpTo: String
  scheduledMeetingInfo: ScheduledMeetingInfoInput!
}

type ScheduledMeetingInfo {
  startTime: DateTime!
  endTime: DateTime!
  exchangeId: String
  iCalUID: String
  eventRecurrenceRange: RecurrenceRange
  eventRecurrencePattern: RecurrencePattern
  eventType: AppointmentType!
  isCancelled: Boolean
  timeZoneId: String
  originalStartTime: DateTime
}

input ScheduledMeetingInfoInput {
  startTime: DateTime!
  endTime: DateTime!
  exchangeId: String
  iCalUID: String
  eventRecurrenceRange: RecurrenceRangeInput
  eventRecurrencePattern: RecurrencePatternInput
  eventType: AppointmentType!
  isCancelled: Boolean
}

type DlpData {
  id: String!
  content: String
  subject: String
  policyTip: PolicyTip
}

type PolicyTip {
  generalText: String
  complianceUrl: String
  matchedConditionDescriptions: [String]
}

type PolicyViolation {
  verdictDetails: Int
  dlpAction: Int
  genericStreamItemId: String!
  state: Int
  justificationText: String
  userAction: Int
  violationType: PolicyViolationType
}

type ImageMeta {
  width: Int!
  height: Int!
}

type FilteredEvents {
  inDayEvents: [InDayEvents!]
  allDayEvents: [AllDayEvents!]
  recurrenceEvents: [RecurrenceEvents!]
  hasError: Boolean
}

type RecurrenceEvents {
  cleanGlobalObjectId: String!
  events: [CalendarEvent!]
  mailboxAddress: String
}

type InDayEvents {
  date: String!
  events: [CalendarEvent!]
  mailboxAddress: String
}

type AllDayEvents {
  date: String!
  events: [CalendarEvent!]
  mailboxAddress: String
}

input AttendeeInput {
  status: ResponseStatusInput
  type: AttendeeType
  address: String
  name: String
  jobTitle: String
  mri: String
  role: String
  broadcastMeetingRole: String
  groupType: AttendeeGroupType
  isGroup: Boolean
  objectId: String
  meetingRole: String
}

input ResponseStatusInput {
  attendance: MeetingAttendanceType
  response: String
  time: String
}

input AttachmentInput {
  id: String!
  name: String
  size: Int!
  contentType: String
  fileName: String
  isInline: Boolean
  contentId: String
  attachmentType: AttachmentType!
  attachLongPathName: String
  providerType: String
  providerEndpointUrl: String
}

input BroadcastSettingsInput {
  isStreamEnabled: Boolean
  isRecordingEnabled: Boolean
  isVodEnabled: Boolean
  isAttendeeReportDisabled: Boolean
  isQAndAEnabled: Boolean
  accessLevel: BroadcastMeetingAccessLevel
  transcriptionSettings: BroadcastTranscriptionSettingsInput
  yammerSettings: BroadcastYammerSettingsInput
  troubleshootingSettings: BroadcastTSSettingsInput
  customLinkSettings: BroadcastCustomLinkSettingsInput
  broadcastAttendees: [AttendeeInput!]
  broadcastETMs: [BroadcastETMInput!]
  modalityLinks: MeetingModalityLinkInput
  userRole: String
  organizerMeetingRole: String
}

input BroadcastCustomLinkSettingsInput {
  url: String
  text: String
}

input BroadcastETMInput {
  mri: String
  broadcastMeetingRole: String
}

input BroadcastTranscriptionSettingsInput {
  transcription: Boolean
  translationCultureNames: [String!]
}

input BroadcastTSSettingsInput {
  link: String
}

input BroadcastYammerSettingsInput {
  isEnabled: Boolean
  groupId: String
  promptText: String
  groupName: String
}

input MeetingModalityLinkInput {
  attendee: String
  attendeeSupport: String
  qnaAttendee: String
  qnaModerator: String
  yammer: MeetingModalityYammerInput
  stream: MeetingModalityStreamInput
}

input MeetingModalityStreamInput {
  published: Boolean
  videoId: String
  ingestUrls: [StreamIngestUrlInput!]
  producerEmbed: String
  attendeeEmbed: String
  analyticsEmbed: String
  addVideoToGroup: Boolean
}

input MeetingModalityYammerInput {
  broadcastId: String
  groupId: String
  published: Boolean
  event: String
}

input StreamIngestUrlInput {
  url: String
  protocol: String
  type: String
}

input SkypeTeamsDataInput {
  cid: String
  rid: ID
  mid: ID
  uid: String
  private: Boolean
  type: Int
}

input RecurrenceRangeInput {
  startDate: ScalarEnumString!
  endDate: ScalarEnumString
}

input RecurrencePatternInput {
  patternType: ScalarEnumString!
  daily: DailyPatternInput
  weekly: WeeklyPatternInput
  monthly: MonthlyPatternInput
  relativeMonthly: RelativeMonthlyPatternInput
  yearly: YearlyPatternInput
  relativeYearly: RelativeYearlyPatternInput
}

input DailyPatternInput {
  interval: Int!
}

input WeeklyPatternInput {
  daysOfTheWeek: [ScalarEnumString!]!
  interval: Int!
}

input MonthlyPatternInput {
  dayOfMonth: Int!
  interval: Int!
}

input RelativeMonthlyPatternInput {
  dayOfTheWeekIndex: ScalarEnumString!
  dayOfTheWeek: ScalarEnumString!
  interval: Int!
}

input YearlyPatternInput {
  month: ScalarEnumString!
  dayOfTheMonth: Int!
}

input RelativeYearlyPatternInput {
  month: ScalarEnumString!
  dayOfTheWeekIndex: ScalarEnumString!
  dayOfTheWeek: ScalarEnumString!
}

input FluidUrlPermissionInfoInput {
  state: FluidUrlPermissionState
  errorCode: String
  grantPermissionVariables: CreateFluidShareLinkVariablesInput
}

input FluidUrlPropertiesInput {
  url: String
  sourceType: String
}

input FluidPropertiesInput {
  fluidUrlProperties: FluidUrlPropertiesInput
}

input CreateFluidShareLinkVariablesInput {
  siteUrl: String!
  itemId: String!
  driveId: String!
  queryParams: String!
  linkType: LinkTypeInput!
  scope: LinkScopeInput!
  recipientList: [DriveRecipientInput!]
  createShareLinkOptions: CreateShareLinkOptions!
}

input ComputedPropertiesInput {
  urlPreview: UrlPreviewInput
  mentions: [MentionInput!]
  onBehalfOf: [MentionInput!]
  cards: [CardInput!]
  amsReferences: [String!]
  """
  An array to store local offline data
  """
  offlineAssets: [String!]
  isExpanded: Boolean
  embeddedLinks: [EmbeddedLinkInput!]
  appIdsToInstall: [String!]
}

input EmbeddedLinkInput {
  """
  Href of the anchor tag
  """
  objectUrl: String!
  """
  text of the anchor tag
  """
  title: String
  """
  Description related to the link
  """
  description: String
  """
  File meta deta for the shared file Url
  """
  fileShareUrlMeta: FileShareUrlMetaInput
}

input FileShareUrlMetaInput {
  """
  objectUrl of the file
  """
  objectUrl: String
  """
  shareUrl of the file
  """
  shareUrl: String
  """
  fileId of the file
  """
  id: String
  """
  Extension type of a file
  """
  type: String
}

input UrlPreviewInput {
  url: String!
  title: String
  description: String
  previewEnabled: Boolean
  thumbnail: String
  thumbnailMeta: ImageMetaInput
}

input FileInput {
  id: ID!
  itemId: ID
  baseUrl: String
  objectUrl: String
  shareUrl: String
  shareId: String
  type: String
  title: String
  state: FileChicletState
  isReferencedFile: Boolean
  serviceName: FileViewServiceName
  previewUrl: String
  chicletBreadcrumbs: ChicletBreadcrumbsInput
  previewHeight: Int
  previewWidth: Int
  progressComplete: Int
  hasUploadFailed: Boolean
  downloadUrl: String
  permissionScope: String
  externalFileShareInfo: String
  context: String
  sharepointIds: SharepointInfoInput
  publication: SharepointPublicationInput
  site: SharepointSiteInput
}

"""
This will be used when adding a deepLink chiclet to a message
"""
input DeepLinkInput {
  """
  Object Id
  """
  id: ID!
  type: String
  """
  display name for the deeplink
  """
  title: String
  channelId: String
  parentContext: String
  """
  site url for the deeplink
  """
  siteUrl: String
  serverRelativeUrl: String
  """
  object url for the deeplink
  """
  objectUrl: String
  """
  chiclet state
  """
  state: DeepLinkChicletState
}

"""
This would be used when a file shared in channel
would be shared in group chat by pasting a
shareUrl of the file
"""
input ChicletBreadcrumbsInput {
  sourceTeamName: String
  sourceChannelName: String
}

input SharepointInfoInput {
  listId: String
  listItemId: String
  listItemUniqueId: String
  siteId: String
  siteUrl: String
  syncResourceId: String
  tenantId: String
  webId: String
}

input SharepointPublicationInput {
  level: String
  versionId: String
}

input SharepointTemplateInput {
  id: String
}

input SharepointSiteInput {
  dataLocationCode: String
  template: SharepointTemplateInput
}

enum PolicyViolationType {
  zap
  dlp
  cc
}

enum FileChicletState {
  active
  deleted
  reference
  hidden
}

enum DeepLinkChicletState {
  active
  deleted
  reference
  hidden
}

enum FileViewServiceName {
  p2p
  customspo
  aggregatefiles
  downloads
  teams
  recent
  personal
  teamsSdk
}

input MentionInput {
  itemId: String!
  userId: String!
  mentionType: String!
  displayName: String!
}

input CardInput {
  appIcon: String
  appId: ID!
  appName: String
  cardClientId: ID!
  content: String!
  contentType: String!
  locale: String
}

input ImageMetaInput {
  width: Int!
  height: Int!
}

input PolicyViolationInput {
  verdictDetails: Int
  dlpAction: Int
  genericStreamItemId: String!
  state: Int
  justificationText: String
  userAction: Int
}

type Device {
  id: String!
  label: String
  type: DeviceType!
  isTeamsCertified: Boolean
}

type AudioDevice {
  id: String!
  label: String
  speakerId: String
  microphoneId: String
  isTeamsCertified: Boolean
  isMultichannel: Boolean
}

type TransportCompanionDeviceInfo {
  transportCompanionDevice: TransportCompanionDevice
  isSelected: Boolean!
}

type TransportCompanionDevice {
  speaker: Device!
  microphone: Device!
  camera: Device!
  audioDevice: AudioDevice!
}

type SelectedDevices {
  microphoneId: String
  speakerId: String
  cameraId: String
  audioDeviceId: String
}

enum DeviceType {
  Camera
  Microphone
  Speaker
}

type EchoBotReport {
  microphoneErrors: [String!]!
  speakerErrors: [String!]!
  cameraErrors: [String!]!
  networkErrors: [String!]!
}

type CallingAlert {
  teamsCallId: ID
  timestamp: BigInt
  alertType: AlertType!
  title: String
  text: String!
  ariaText: String
  severity: AlertSeverity!
  actions: [AlertAction!]
  dismissable: Boolean
  narrated: Boolean
}

type AlertAction {
  text: String
  isSecondary: Boolean
  actionId: AlertActionType!
}
"""
Also known as UFD
"""
type UserFacingDiagnosticsV2 {
  isEnabled: Boolean!
}

enum AlertSeverity {
  """
  Also known as Affirmational
  """
  Info
  Warning
  """
  Also known as Critical
  """
  Error
  Standalone
}

enum AlertActionType {
  AcceptBreakoutRoomInvite
  AllowControl
  betterTogetherTransferCall
  BroadcastLearnMore
  BroadcastModalityReconnect
  CloseVideoApp
  MeetingAttendeeUfdRaiseHand
  DeclineBreakoutRoomInvite
  DenyControl
  DownloadApp
  MuteSpeakerAndMicAudio
  NdiPrivacyPolicyCapturer
  PrivacyPolicyParticipant
  OpenAudioEscalationDialog
  SwitchDevice
  OpenDeviceSettings
  OpenLearnMoreLink
  OpenMeetingInfo
  OpenPrivacyPolicyLink
  OpenVideoDevicePermission
  OptOutFromVoiceCollection
  CloseVoiceCollection
  PaywallUpgrade
  PstnDialInManually
  PstnDialOutManually
  RejoinAsGuest
  ReportScdFailure
  ShowPstnDialog
  StartChromeExtensionInstallation
  StartContentSharing
  StartScreenSharingOnCall
  StartTranscript
  StartRecording
  SwitchMicrophone
  SwitchShareContent
  ViewLobby
  TerminateControl
  TakePptSharingControl
  TryAgain
  TurnCameraOn
  TurnOffVoiceIsolationForThisMeeting
  ToggleHighFidelityMusicMode
  UnmuteMicAudio
  UnmuteSpeakers
  StartMeeting
  EnableScreenshareRecording
  DisableIncomingAndOutgoingVideo
  UnmuteMicAndSpeakers
  OpenInterpretationDialog
  ControlRoomSystemPanel
  """
  Used to cancel interop screen share alert with a separate Cancel button instead of the 'X' dismiss button.
  Do not use this if you do not need a separate Cancel button.
  """
  Cancel
  ViewBreakoutRooms
  LowerHandNow
  KeepHandRaised
  LowerHand
  OpenAudioDevicePermission
}

enum AlertType {
  ACSRecordingStarted
  ACSRecordingStopped
  ACSUserJoined
  ACSUserLimitedCapabilities
  AddMemberToChatFailed
  APLDisabledInCompanionMode
  AttendeeBringOffStageAlert
  AttendeeBringOnStageAlert
  AttendeeHostViewModeActivated
  AttendeeHostViewModeActivatedRaiseHand
  AttendeeHostViewModeDeactivated
  AudioCaptureMusicDetectedWithHighNS
  AudioCaptureMusicDetectedWithLowNS
  AudioCaptureUltrasoundDetected
  AudioCaptureUltrasoundDetectedWithUnmuteButton
  AudioCaptureUltrasoundDetectedWithMuteButton
  AudienceViewFailed
  AudienceViewSceneAck
  AudienceViewSceneChanged
  AudienceViewSceneChangeFailed
  BetterTogetherOutOfProximityWarning
  Bmc_setLayout_command_failure
  Bmc_setLayout_command_video_stall
  Bmc_start_command_failure
  Bmc_stop_command_failure
  Bmc_restart_command_failure
  BreakoutRoomAnnouncement
  BreakoutRoomsBulkMoveFailure
  BreakoutRoomsControlLost
  BreakoutRoomsPanelClosedOnRoomsDeleted
  BreakoutRoomsParticipantHasNoRoomsToChoose
  BreakoutRoomsParticipantHasRoomsToChoose
  BreakoutRoomCannotMoveDisconnectedParticipants
  BreakoutRoomCloseCreateBrDialog
  BreakoutRoomCreationFailed
  BreakoutRoomEnding
  BreakoutRoomInvite
  BreakoutRoomLockXlMeeting
  BreakoutRoomBulkCreationFailed
  BreakoutRoomBulkCreationSucceeded
  BreakoutRoomBulkCreationFailedRoomsAlreadyExist
  BreakoutRoomOptimisticOpenStarted
  BreakoutRoomOptimisticCloseStarted
  Broadcast_captions_disabled_by_ETM
  Broadcast_concurrent_videos_limit
  Broadcast_end_warning
  Broadcast_ipvideo_permission
  Broadcast_ipvideo_vbss_permission
  Broadcast_noCamera
  Broadcast_preview_overflow_warning
  Broadcast_reset_done
  Broadcast_vbss_permission
  BroadcastModalityDisconnected
  BroadcastModalityNotReceived
  BroadcastMutedProducerWarning
  BroadcastStopped
  CameraUnmuteTakesLongerTime
  CannotUnmuteOSMicrophone
  ClosedCaptionsStartFailed
  CoachNotification
  CoachStarted
  CoachStartFailed
  CoachStopped
  CoachStopFailed
  ComplianceRecordingE2EEJoinError
  ComplianceRecordingStarted
  ComplianceRecordingStopped
  ComplianceRecordingStartedByCurrentUser
  ComplianceRecordingStartedByCurrentUserAndOthers
  ConsentToRecordingError
  ContentOnlyAlert
  ContentOnlyFromNudgeAlert
  ContentSharingFailed
  ControlRoomSystemAlert
  CpuInsufficient
  CurrentMeetingIsXL
  DenyConsentToRecordingError
  DeviceAtCallStart
  DeviceCaptureMute
  DeviceCaptureNotFunctioning
  DeviceCaptureNotFunctioningAudioSrvNotRunning
  DeviceCaptureNotMuteButSilent
  DeviceClipping
  DeviceHowling
  DeviceLowSNR
  DeviceMultipleEndpoints
  DeviceNearEndToEchoRatio
  DeviceRenderHowling
  DeviceRenderMute
  DeviceRenderNotFunctioning
  DeviceRenderNotFunctioningAudioSrvNotRunning
  DeviceRenderZeroVolume
  DeviceSpeakWhileMuted
  DisableIncomingMeetingAudio
  EndToEndEncryptedMeetingMaxCapacity
  EnableIncomingMeetingAudio
  EndOfMeetingAlert
  FaceStreamEndedForCall
  FaceStreamStartedForCall
  GreenRoomStartMeetingAlert
  GreenRoomParticipantFailedToBeMovedAlert
  GreenRoomMeetingGoLiveFailedAlert
  LargeGalleryViewFailed
  HardwareOutMeetingSendToDevice
  HardwareOutMeetingStopDevice
  HolographicAnnotationsError
  HostViewModeActivated
  HostViewModeDeactivated
  ImageRenderingQualityAlert
  ImmersiveViewUnsupportedContentAlert
  InitiatorStartedRecording
  InsufficientMeetingRole
  InteropCallAlert
  InteropScreenshare
  InterpretationAvailable
  JoinersOngoingRecording
  LocalDeviceEcho
  LockedScreenInCall
  LowerHandPrompt
  MaskIdentitiesForRole
  Meeting_attendee_restrictions_operation_failure
  Meeting_attendees_audio_failed
  Meeting_attendees_audio_restricted
  Meeting_attendees_audio_unrestricted
  Meeting_attendees_video_failed
  Meeting_attendees_video_restricted
  Meeting_attendees_video_unrestricted
  Meeting_self_attendee_audio_restricted
  Meeting_self_attendee_audio_unrestricted
  Meeting_self_attendee_video_restricted
  Meeting_self_attendee_video_unrestricted
  MeetingLocked
  MeetingLockedError
  MeetingUnlocked
  MeetingRoleChanged
  MergeFailedAlert
  MicMutedRemotely
  MicUnmuteTakesLongerTime
  HighFidelityAudioToggled
  HighFidelityAudioToggleFailure
  NdiMeetingBroadcastCapturer
  NdiMeetingBroadcastStoppedCapturer
  NdiMeetingBroadcastParticipant
  NdiMeetingBroadcastStoppedParticipant
  NetworkErrorForOrganizer
  NetworkQuality
  NetworkReconnect
  NetworkRecvCatastrophicPoorTurnOffVideo
  NetworkRecvCatastrophicPstnAvailable
  NetworkRecvCatastrophicPstnNotAvailable
  NetworkSendCatastrophicPoorTurnOffVideo
  NetworkSendCatastrophicPstnAvailable
  NetworkSendCatastrophicPstnNotAvailable
  NoAvailableMicrophone
  NoAvailableSpeakers
  NoRequiredVideoCodecs
  OverflowRoomCreated
  ParticipantsRecordingStarted
  PaywallTimerStart
  PaywallRemainingDuration
  PaywallRemainingParticipantCapacity
  PeopleFeedEndedForCall
  PeopleFeedStartedForCall
  PersonalNoiseSuppressionMethodChanged
  PlazaEditMisrecognizedParticipantFailed
  PossibleBrowserPopoutForPSTNCall
  PptContentSharingConsent
  PptContentSharingUnsupportedMeeting
  PptPresentOnMeetingStart
  PptPrivateViewingFailed
  PptSharingStolen
  PptSharingUnavailable
  PptUnsupportedUpload
  PptWeatherpersonFailed
  PSTNCallLBRFailure
  PSTNDomesticRestrictedFailure
  PSTNEntitlementFailure
  RaiseHandsOperationFailure
  RecordingAndTranscriptFailed
  RecordingAndTranscriptPending
  RecordingAndTranscriptStarted
  RecordingAndTranscriptStartedByOthers
  RecordingAndTranscriptStopFailed
  RecordingAndTranscriptStopped
  RecordingAndTranscriptWaitingForMeetingLive
  RecordingDisabled
  RecordingExited
  RecordingFailed
  RecordingFailedTranscriptPending
  RecordingFailedTranscriptStarted
  RecordingPPT
  RecordingStartedTranscriptPending
  RecordingSpotlight
  RecordingStopped
  RecordingUnavailable
  RecordingWaitingForMeetingLive
  RecordingWhiteboard
  RemoteDeviceEcho
  RenameFailed
  RigelAutoExitMeetingAlert
  RigelDisplayDisconnected
  RigelParticipantsInLobby
  RigelRoomPeopleCountChanged
  RigelUrlBlocked
  ScreenShareContentNotSupportedForOverflow
  ScreenshareRecordingDisabled
  ScreensharingCallEscalatedToAudio
  ScreensharingCallEscalatedToAudioFailed
  ScreenSharingNotSupported
  ScreenSharingRenderingError
  ScreenSharingWindowMinimizedPopUpAlert
  SensitivityLabelAlert
  SharedWindowMinimized
  SharingControlRequestDenied
  SharingControlRequestRevoked
  SharingDropped
  SharingFailed
  SharingStolen
  SharingGiveTakeControlError
  SharingIncomingControlRequest
  SharingTerminateControl
  SuppressingBackgroundNoiseAlert
  NewAudioDevicePluggedInAlert
  NewVideoDevicePluggedInAlert
  AudioDeviceSelectionChangedAlert
  ActiveAudioDevicePluggedOutAlert
  ActiveVideoDevicePluggedOutAlert
  ScdFailed
  ScdStopped
  ScdSucceeded
  SpeakerAndMicUnmuted
  SpokenLanguageChanged
  SpotlightError
  SpotlightStatusChanged
  SpotlightStatusOn
  SpotlightStatusOff
  StreamingMeetingStarted
  StreamingMeetingStopped
  SystemAudioDevicesMismatchInCallingScreen
  SystemAudioNoDeviceInCallingScreen
  SystemAudioDevicesNotMatch
  SystemAudioDevicesStoppedWithError
  SystemAudioDriverInstallationFailed
  SystemAudioDriverInstallationSucceeded
  SystemAudioNoDevice
  SystemAudioStarted
  SystemAudioUnsupportedSharing
  TemporarilyUnmuted
  TogetherModePinError
  TogetherModePinStatusOn
  TranscriptFailedRecordingPending
  TranscriptFailedRecordingStarted
  TranscriptStarted
  TranscriptStartedByOthers
  TranscriptStartedRecordingPending
  TranscriptStartFailed
  TranscriptStopFailed
  TranscriptStopped
  TranscriptWaitingForMeetingLive
  UnmuteWithoutConsent
  UserHandLoweredByPresenter
  VideoCaptureDeviceFreeze
  VideoCaptureFreezeRecovered
  AudioCapturePermissionDenied
  VideoCapturePermissionDenied
  VideoCapturerDeviceStartFailed
  VideoCapturerDeviceStartFailureLackSystemRes
  VideoCapturerDeviceStartFailureMFResConflict
  VideoCapturerDeviceStartTimedOut
  VideoExtensibilityDisabledInStandoutMode
  VideoExtensibilityFreeze
  VideoExtensibilitySlow
  VideoEffectsQualityDegraded
  VoiceCollectionFailed
  VoiceCollectionStarted
  VoiceCollectionStopped
  WatermarkAnonymousUser
  WatermarkUnsupportedPlatformUser
  WatermarkVideoStreamStart
  WeatherpersonContentNotSupported
  WeatherpersonVideoStopped
}

type CallPrejoinCapabilities {
  isVideoBackgroundSettingsDisabled: Boolean
  isInCallDeviceSettingsDisabled: Boolean
  isPrejoinPreviewDisabled: Boolean
  isPhoneAudioJoinOptionDisabled: Boolean
  isContentOnlyOptionDisabled: Boolean
  isAddRoomOptionDisabled: Boolean
}

type CallCapabilities {
  isTransferAllowed: Boolean
  isCallParkAvailable: Boolean
  isVideoPreviewDisabled: Boolean
  isVideoBackgroundSettingsDisabled: Boolean
  isPSTNCallbackOptionDisabled: Boolean
  isSafeTransferAllowed: Boolean
  isCloudRecordingAllowed: Boolean
  allowedRecorder: RecorderOption
  isTranscriptionAllowed: Boolean
  isIpVideoAllowed: Boolean
  isSingleOutgoingVideoEnabled: Boolean
  """
  deprecated properties, needs to be cleaned up
  """
  isRecordingStorageStreamAllowed: Boolean
}

type PstnCapabilities {
  isDialInEnabled: Boolean!
  isDialOutEnabled: Boolean!
  isLbrEnabledUser: Boolean!
}

type CallStateProps {
  title: String!
  descriptionTitle: String!
  descriptionText: String!
  hyperLinkInTitle: String
  icon: String
  useOutlineIcon: Boolean
  telemetryContext: String
}

type PptSharingContentDto {
  id: ID!
  name: String!
  etag: String
  siteId: String
  url: String
  contentBundleUrl: String
  fileGetUrl: String
  customFontCatalogUrl: String
  majorVersion: Int!
  fileSize: Int!
  bootstrapperUrl: String!
  wacUrl: String
  webUrl: String
  source: PptSharingSource
  correlationId: String
}

enum PptSharingSource {
  upload
  recent
  channel
  attachment
  cortana
  deepLink
  onedrive
  deepLink_online
  deepLink_win32
  windowSharingIntercept
}

enum ShareableContentType {
  ppt
  invision_whiteboard
  whiteboard
  extensible_app
  annotation
  mesh_app
}

type ExchangeContentMeta {
  type: String
  eventId: String
}

type ScreenSharingBounds {
  top: Int
  left: Int
  width: Int
  height: Int
}

type PptSharingContent {
  id: ID!
  name: String!
  type: ShareableContentType!
  source: PptSharingSource!
  exchangeMeta: ExchangeContentMeta
  icon: String
  url: String
  correlationId: String
  siteUrl: String
  appName: String
}

type WhiteboardSharingContent {
  id: ID!
  type: ShareableContentType!
  url: String
  icon: String
  conversationId: ID!
  messageId: ID!
  loaderLabel: String
  initiatorParticipantId: String
  permittedFileUsers: [String] @deprecated(reason: "Use extensibleAppContext")
  pendingFilePermittedUsers: [String]
    @deprecated(reason: "ExtensibleAppContext")
  failedFilePermittedUsers: [String]
    @deprecated(reason: "Use extensibleAppContext")
  extensibleAppContext: String
}

"""
Will replace WhiteboardSharingContent in order to make code flow more generic
"""
type CallAppContentSharingContent {
  id: ID!
  type: ShareableContentType!
  url: String
  icon: String
  conversationId: ID!
  messageId: ID!
  loaderLabel: String
  initiatorParticipantId: String
  permittedFileUsers: [String] @deprecated(reason: "Use extensibleAppContext")
  pendingFilePermittedUsers: [String]
    @deprecated(reason: "Use extensibleAppContext")
  failedFilePermittedUsers: [String]
    @deprecated(reason: "Use extensibleAppContext")
  extensibleAppContext: String
}

type PptTimelineMapping {
  step: Int!
  timelineId: ID!
  lastClickTime: Int!
  startTimeOffset: Int!
}

type SlideEvent {
  slideIndex: Int!
  timelineMappings: [PptTimelineMapping!]
}

enum CallDeviceShortcutType {
  pptLaserPointLongPressed
  pptLaserPointReleased
  pptPrevSlidePressed
  pptNextSlidePressed
}

type PptBootTelemetry {
  docClickTime: BigInt
  driveItemRequestStartTime: BigInt
  driveItemRequestEndTime: BigInt
  spoApiCallsCount: Int
  officeBootstrapperStartTime: BigInt
  officeBootstrapperEndTime: BigInt
  loadingSpinnerStartTime: BigInt
  incomingSessionJoinedTime: BigInt
  presentationUrlUpdateMetadata: String
  presenterStartTime: BigInt
  timeFromPresenterStartToAttendee: BigInt
  bootstrapperScriptLoadPoint: String
}

type PptMediaPlaybackState {
  playerName: String!
  playing: Boolean!
  position: Float!
  volume: Float
  timestamp: Float
}

type PptCameoState {
  cameoDetectedInCurrentSlide: Boolean
  cameoDetectedInPresentation: Boolean
  hasAutoEnteredCameo: Boolean
  shouldAutoEnterCameo: Boolean
}

type PptSharingSession {
  id: ID!
  slideEvent: SlideEvent!
  content: PptSharingContentDto!
  mode: PptSharingContentMode!
  privateViewingEnabled: Boolean!
  """
  DEPRECATED use docClickTime instead
  """
  documentClickTime: String
  ring: String
  position: Int
  docClickTime: DateTime
  bootTelemetry: PptBootTelemetry
  presentationUrl: String
  isPresentationUrlEnabledForPresenter: Boolean
  stateServiceFeaturesEnabledForPresenter: [String]
  mediaStates: [PptMediaPlaybackState!]
  cameoState: PptCameoState
}

enum SharingLayoutMode {
  Cameo
  ContentOnly
  Weatherperson
  SideBySide
  NewsAnchor
}

type StreamMetadataWithId {
  streamId: Int!
  bufferName: String
  error: String
  isNativeRendering: Boolean
  compositorId: ID
}

enum PptSharingContentMode {
  Unestablished
  Viewing
  BrowsingPrivately
  Presenting
  Starting
  Joining
}

enum WhiteboardSharingContentMode {
  Unestablished
  Viewing
  Presenting
}

"""
Will replace WhiteboardSharingContentMode in order to make code flow more generic
"""
enum CallAppContentSharingMode {
  Unestablished
  Viewing
  Presenting
}

enum CallTranscriptEntryType {
  None
  Text
  StartEvent
  StopEvent
  ParticipantJoined
  ParticipantLeft
  RoomAttributionStarted
  RoomAttributionStopped
}

type CallTranscriptEntry {
  entryId: ID!
  type: CallTranscriptEntryType!
  timestamp: String!
  text: String!
  originalText: String
  speakerId: String
  speakerDisplayName: String
  isPartial: Boolean
  roomId: String
  roomDisplayName: String
  editorId: String
  editorDisplayName: String
  source: String
  utteranceId: String
  spokenLanguage: String
  trackLanguage: String
}

enum LayoutType {
  None
  Gallery
  Content
  ContentWithGallery
}

enum BroadcastParticipantRole {
  Producer
  Contributor
  Attendee
  None
}

type BroadcastStreamingInfo {
  wamsStreamingUrl: String
  wamsHlsStreamingUrls: [String!]
  decryptionToken: String
  decryptionKey: StreamDecryptionKey
  keyAuthorizationToken: String
  setKeyAuthorizationCookieUri: String
  sdn: SDNDetails
  deliveryPipelineType: String
}

type SDNDetails {
  name: String!
  playbackInfo: String!
  pluginUrl: String!
  sdkUrl: String
}

type BroadcastStreamingDetails {
  id: ID!
  stream: BroadcastStreamingInfo!
  altStream: BroadcastStreamingInfo!
}

type BroadcastTranscription {
  id: ID!
  isEnabled: Boolean
  isSuppressed: Boolean
  transcriptionLanguage: String
  translationLanguages: [String]
  captionsCacheUrl: String
  captionsOriginUrl: String
}

enum PresenceSource {
  ups
  sfb
}

enum PresenceExpirationOptions {
  Never
  OneHour
  FourHours
  Today
  ThisWeek
  Custom
}

enum AppInstallScope {
  Personal
  Team
  GroupChat
}

enum MeetingSurface {
  Unknown
  SidePanel
  Stage
}

enum ConfigurableTabContext {
  Unknown
  PersonalTab
  ChannelTab
  PrivateChatTab
  MeetingChatTab
  MeetingDetailsTab
  MeetingSidePanel
  MeetingStage
  CallingSidePanel
}

enum StaticTabContext {
  Unknown
  PersonalTab
  ChannelTab
  PrivateChatTab
  MeetingChatTab
  MeetingDetailsTab
  MeetingSidePanel
  MeetingStage
  TeamLevelApp
}

type AppSuggestion {
  id: ID!
}

type SkypeTeamsAppRanking {
  id: ID!
  appRanking: [AppRanking!]
}

type InstallationRanking {
  install: Int!
  version: String
}

type AppRanking {
  ranking: InstallationRanking!
  id: ID!
  name: String
}

type AppDefinition {
  id: ID!
  name: String
  shortDescription: String
  longDescription: String
  smallImageUrl: String
  largeImageUrl: String
  accentColor: String
  manifestVersion: String
  version: String
  externalId: String
  language: String
  developerName: String
  developerUrl: String
  privacyUrl: String
  termsOfUseUrl: String
  supportedLanguages: [String]
  bots: [BotDefinition!]
  customBots: [CustomBotDefinition!]
  galleryTabs: [GalleryTabDefinition!]
  staticTabs: [StaticTabDefinition!]
  messageExtensions: [MessageExtensionDefinition!]
  extensions: [OutlookExtensionsDefinition!]
  connectors: [ConnectorDefinition!]
  validDomains: [String!]
  categories: [String!]
  tenantId: String
  devicePermissions: [String!]
  isCoreApp: Boolean
  isBlocked: Boolean
  isFullScreenApp: Boolean
  isFullTrustApp: Boolean
  showTabLoadingIndicator: Boolean
  webApplicationInfo: WebApplicationInfo
  mpnId: String
  screenshotUrls: [String!]
  officeAssetId: String
  videoUrl: String
  meetingExtensionDefinition: MeetingExtensionDefinition
  securityComplianceInfo: SecurityComplianceInfo
  authorization: AppAuthorization
  defaultInstallScope: AppDefaultInstallScope
  defaultGroupCapability: AppDefaultGroupCapability
  subscriptionOffer: SubscriptionOffer
  exchangeAddInElement: ExchangeAddInElement
  storeExtensionAttributes: StoreExtensionAttributes
  elementTypes: [ElementType!]
  isMicrosoftOwned: Boolean
  permissions: [PlatformAppPermission!]
  freePlan: AppFreePlan
}

input AppDefinitionInput {
  id: ID!
  name: String
  shortDescription: String
  longDescription: String
  smallImageUrl: String
  largeImageUrl: String
  accentColor: String
  manifestVersion: String
  version: String
  externalId: String
  language: String
  developerName: String
  developerUrl: String
  privacyUrl: String
  termsOfUseUrl: String
  supportedLanguages: [String]
  bots: [BotDefinitionInput!]
  customBots: [CustomBotDefinitionInput!]
  galleryTabs: [GalleryTabDefinitionInput!]
  staticTabs: [StaticTabDefinitionInput!]
  messageExtensions: [MessageExtensionDefinitionInput!]
  connectors: [ConnectorDefinitionInput!]
  validDomains: [String]
  categories: [String!]
  tenantId: String
  devicePermissions: [String!]
  isCoreApp: Boolean
  isFullScreenApp: Boolean
  isFullTrustApp: Boolean
  showTabLoadingIndicator: Boolean
  webApplicationInfo: WebApplicationInfoInput
  mpnId: String
  screenshotUrls: [String!]
  officeAssetId: String
  videoUrl: String
  meetingExtensionDefinition: MeetingExtensionDefinitionInput
  resource: String
  authorization: AppAuthorizationInput
  defaultInstallScope: AppDefaultInstallScope
  defaultGroupCapability: AppDefaultGroupCapabilityInput
  isMicrosoftOwned: Boolean
}

type AppAuthorization {
  permissions: AppPermissions
}

type AppPermissions {
  orgWide: [AppPermissionNode]
  resourceSpecific: [AppPermissionNode]
}

type AppPermissionNode {
  name: String
  type: AppPermissionNodeType
}

enum AppPermissionNodeType {
  Application
  Delegated
}

type AppFreePlan {
  mayRequireAdditionalPurchases: Boolean
}

input AppAuthorizationInput {
  permissions: AppPermissionsInput
}

input AppPermissionsInput {
  orgWide: [AppPermissionNodeInput]
  resourceSpecific: [AppPermissionNodeInput]
}

input AppPermissionNodeInput {
  name: String
  type: AppPermissionNodeType
  securityComplianceInfo: SecurityComplianceInfoInput
}

enum AppDefaultInstallScope {
  Personal
  Team
  GroupChat
  Meetings
}

enum AppGroupCapability {
  Tab
  Bot
  Connector
}

type AppDefaultGroupCapability {
  team: AppGroupCapability
  groupchat: AppGroupCapability
  meetings: AppGroupCapability
}

input AppDefaultGroupCapabilityInput {
  team: AppGroupCapability
  groupchat: AppGroupCapability
  meetings: AppGroupCapability
}

type SubscriptionOffer {
  offerId: String
}

type ExchangeAddInElement {
  name: String
}

type StoreExtensionAttributes {
  host: StoreExtensionHost
}

type StoreExtensionHost {
  mailHosts: [MailHost!]
}

type MailHost {
  desktopFormFactor: HostFormFactorProperties
  mobileFormFactor: HostFormFactorProperties
}

type HostFormFactorProperties {
  extensionPointTypes: [ExtensionPointTypes!]
}

enum ExtensionPointTypes {
  MessageReadCommandSurface
  MessageComposeCommandSurface
  AppointmentOrganizerCommandSurface
  AppointmentAttendeeCommandSurface
}

enum ElementType {
  Unknown
  OfficeAddIn
  OfficeAddIns
  ExchangeAddIn
  ExchangeAddIns
  LineOfBusiness
  Bot
  Bots
  MessageExtension
  ComposeExtensions
  Extension
  Extensions
  FirstPartyPages
  Dynamics
  AAD
  LaunchPage
  StaticTabs
  GraphConnector
  ConfigurableTabs
  Connector
  Connectors
  Activity
  Activities
  MeetingExtension
  MeetingExtensionDefinition
}

enum PlatformAppPermission {
  Identity
  MessageTeamMembers

  """
  Outlook specific permissions
  """
  SendReceiveData
  ContactData
  FullAccess
  PublishToInternet
  ReadAllDocument
  ReadDocument
  ReadItem
  ReadWriteDocument
  ReadWriteItem
  ReadWriteMailbox
  Restricted
  WriteDocument
}

type MeetingExtensionDefinition {
  isAnonymousAccessAllowed: Boolean
  scenes: [Scene]
  supportsStreaming: Boolean
  filters: [AudioVideoFilter]
  videoAppContentUrl: String
}

input MeetingExtensionDefinitionInput {
  isAnonymousAccessAllowed: Boolean
  scenes: [SceneInput]
  supportsStreaming: Boolean
  filters: [AudioVideoFilterInput]
  videoAppContentUrl: String
}

input SecurityComplianceInfoInput {
  mcasId: String
  status: String
  csaId: String
  csaName: String
}

type SecurityComplianceInfo {
  mcasId: String
  status: String
  csaId: String
  csaName: String
}

type Scene {
  id: ID!
  name: String
  file: String
  preview: String
  maxAudience: Int
  seatsReservedForOrganizersOrPresenters: Int
}

type AudioVideoFilter {
  id: ID!
  name: String
  thumbnail: String
}

input SceneInput {
  id: ID!
  name: String
  file: String
  preview: String
  maxAudience: Int
  seatsReservedForOrganizersOrPresenters: Int
}

input AudioVideoFilterInput {
  id: ID!
  name: String
  thumbnail: String
}

type BotDefinition {
  id: String!
  scopes: [AppInstallScope]
  commandLists: [CommandListDefinition!]
  capabilities: BotCapabilities
  configuration: BotConfiguration
}

input BotDefinitionInput {
  id: String!
  scopes: [AppInstallScope]
  commandLists: [CommandListDefinitionInput!]
  capabilities: BotCapabilitiesInput
  configuration: BotConfigurationInput
}

type BotConfiguration {
  groupChat: BotConfigurationScope
  team: BotConfigurationScope
}

input BotConfigurationInput {
  groupChat: BotConfigurationScopeInput
  team: BotConfigurationScopeInput
}

type BotConfigurationScope {
  fetchTask: Boolean
  taskInfo: MessageExtensionCommandTaskInfo
}

input BotConfigurationScopeInput {
  fetchTask: Boolean
  taskInfo: MessageExtensionCommandTaskInfoInput
}

type BotCapabilities {
  supportsCalling: Boolean
  supportsVideo: Boolean
  supportsFiles: Boolean
  isNotificationOnly: Boolean
}

input BotCapabilitiesInput {
  supportsCalling: Boolean
  supportsVideo: Boolean
  supportsFiles: Boolean
  isNotificationOnly: Boolean
}

type CustomBotDefinition {
  endpointUrl: String
  secret: String
}

input CustomBotDefinitionInput {
  endpointUrl: String
  secret: String
}

type GalleryTabDefinition {
  configurationUrl: String
  canUpdateConfiguration: Boolean
  canHaveTabConversation: Boolean
  scopes: [AppInstallScope]
  meetingSurfaces: [MeetingSurface]
  context: [ConfigurableTabContext]
}

type OutlookExtensionsDefinition {
  requirements: OutlookRequirements
  runtimes: [OutlookRuntimes]
  ribbons: [OutlookRibbons]
  autoRunEvents: [OutlookAutoRunEvents]
  alternates: [OutlookAlternates]
  audienceClaimUrl: String
}

type OutlookRequirements {
  scopes: [OutlookRequirementsScope]
  capabilities: [OutlookRequirementsCapability]
  formFactors: [OutlookRequirementsFormFactor]
}

enum OutlookRequirementsScope {
  mail
}

enum OutlookRequirementsFormFactor {
  desktop
  mobile
}

type OutlookRequirementsCapability {
  name: String
  minVersion: String
  maxVersion: String
}

type OutlookRuntimes {
  requirements: OutlookRequirements
  id: ID
  type: OutlookRuntimesType
  code: OutlookRuntimesCode
  lifetime: OutlookRuntimesLifetime
  actions: [OutlookRuntimesAction]
}

enum OutlookRuntimesType {
  general
}

type OutlookRuntimesCode {
  page: String
  script: String
}

enum OutlookRuntimesLifetime {
  short
  long
}

type OutlookRuntimesAction {
  id: ID
  type: String
  displayName: String
  view: String
  pinnable: Boolean
}

type OutlookRibbons {
  requirements: OutlookRequirements
  contexts: [OutlookRibbonsContext]
  tabs: [OutlookRibbonsTab]
}

enum OutlookRibbonsContext {
  mailRead
  mailCompose
  meetingDetailsOrganizer
  meetingDetailsAttendee
}

type OutlookRibbonsTab {
  id: ID
  label: String
  position: OutlookRibbonsTabPostion
  builtInTabId: String
  groups: [OutlookRibbonsTabGroup]
}

type OutlookRibbonsTabPostion {
  builtInTabId: String
  align: OutlookRibbonsTabPostionAlign
}

enum OutlookRibbonsTabPostionAlign {
  after
  before
}

type OutlookRibbonsTabGroup {
  id: ID
  label: String
  icons: [OutlookRibbonsTabGroupIcon]
  controls: [OutlookRibbonsTabGroupControl]
  builtInGroupId: String
}

type OutlookRibbonsTabGroupControl {
  id: ID
  type: OutlookRibbonsTabGroupControlType
  label: String
  icons: [OutlookRibbonsTabGroupIcon]
  supertip: OutlookRibbonsTabGroupSupertip
  actionId: String
  overriddenByRibbonApi: Boolean
  enabled: Boolean
  builtInGroupId: String
  items: [OutlookRibbonsTabGroupItem]
}

enum OutlookRibbonsTabGroupControlType {
  button
  menu
}

type OutlookRibbonsTabGroupIcon {
  size: Int
  file: String
  url: String
}

type OutlookRibbonsTabGroupSupertip {
  title: String
  description: String
}

type OutlookRibbonsTabGroupItem {
  id: ID
  type: String
  label: String
  icons: [OutlookRibbonsTabGroupIcon]
  supertip: OutlookRibbonsTabGroupSupertip
  actionId: String
  overriddenByRibbonApi: Boolean
}

type OutlookAutoRunEvents {
  requirements: OutlookRequirements
  events: [OutlookAutoRunEvent]
}

type OutlookAutoRunEvent {
  type: String
  actionId: String
  options: OutlookAutoRunEventOptions
}

type OutlookAutoRunEventOptions {
  sendMode: OutlookAutoRunEventOptionsSendMode
}

enum OutlookAutoRunEventOptionsSendMode {
  promptUser
  softBlock
  block
}

type OutlookAlternates {
  requirements: OutlookRequirements
  prefer: OutlookAlternatesPrefer
  hide: OutlookAlternatesHide
}

type OutlookAlternatesPrefer {
  comAddin: OutlookAlternatesPreferComAddin
}

type OutlookAlternatesPreferComAddin {
  progId: String
}

type OutlookAlternatesHide {
  storeOfficeAddin: OutlookAlternatesHideStoreOfficeAddin
  customOfficeAddin: OutlookAlternatesHideCustomOfficeAddin
}

type OutlookAlternatesHideStoreOfficeAddin {
  officeAddinId: String
  assetId: String
}

type OutlookAlternatesHideCustomOfficeAddin {
  officeAddinId: String
}

input GalleryTabDefinitionInput {
  configurationUrl: String
  canUpdateConfiguration: Boolean
  canHaveTabConversation: Boolean
  scopes: [AppInstallScope]
  meetingSurfaces: [MeetingSurface]
  context: [ConfigurableTabContext]
}

type StaticTabDefinition {
  entityId: String
  name: String
  order: Int
  contentUrl: String
  contentBotId: String
  websiteUrl: String
  scopes: [AppInstallScope]
  context: [StaticTabContext]
  containerAppIds: [String!]
  displayInNonGeneralChannel: Boolean
}

input StaticTabDefinitionInput {
  entityId: String
  name: String
  order: Int
  contentUrl: String
  contentBotId: String
  websiteUrl: String
  scopes: [AppInstallScope]
  context: [StaticTabContext]
  containerAppIds: [String!]
}

type MessageExtensionDefinition {
  type: MessageExtensionType
  botId: String
  scopes: [AppInstallScope]
  commands: [MessageExtensionCommand!]
  canUpdateConfiguration: Boolean
  messageHandlers: [MessageExtensionMessageHandler!]
  fetchCommands: Boolean
}

input MessageExtensionDefinitionInput {
  type: MessageExtensionType
  botId: String
  scopes: [AppInstallScope]
  commands: [MessageExtensionCommandInput!]
  canUpdateConfiguration: Boolean
  messageHandlers: [MessageExtensionMessageHandlerInput!]
  fetchCommands: Boolean
}

type ConnectorDefinition {
  connectorId: String
  configurationUrl: String
  scopes: [AppInstallScope]
}

input ConnectorDefinitionInput {
  connectorId: String
  configurationUrl: String
  scopes: [AppInstallScope]
}

type CommandListDefinition {
  commands: [CommandDefinition!]
  scopes: [AppInstallScope]
}

input CommandListDefinitionInput {
  commands: [CommandDefinitionInput!]
  scopes: [AppInstallScope]
}

enum MessageExtensionType {
  BotBased
  ApiBased
}

enum MessageExtensionCommandType {
  Query
  Action
}

type MessageExtensionMessageHandler {
  type: String
  value: MessageExtensionMessageHandlerValue
}

input MessageExtensionMessageHandlerInput {
  type: String
  value: MessageExtensionMessageHandlerValueInput
}

type CommandDefinition {
  title: String
  description: String
}

input CommandDefinitionInput {
  title: String
  description: String
}

type MessageExtensionMessageHandlerValue {
  domains: [String!]
  supportsAnonymousAccess: Boolean
}

input MessageExtensionMessageHandlerValueInput {
  domains: [String!]
  supportsAnonymousAccess: Boolean
}

type MessageExtensionCommand {
  id: String
  title: String
  context: [MessageExtensionCommandContextType!]
  description: String
  initialRun: Boolean
  type: MessageExtensionCommandType
  parameters: [MessageExtensionParameter!]
  fetchTask: Boolean
  taskInfo: MessageExtensionCommandTaskInfo
  appKey: String
  imageUrls: [String!]
}

input MessageExtensionCommandInput {
  id: String!
  title: String
  context: [MessageExtensionCommandContextType!]
  description: String
  initialRun: Boolean
  type: MessageExtensionCommandType
  parameters: [MessageExtensionParameterInput!]
  fetchTask: Boolean
  taskInfo: MessageExtensionCommandTaskInfoInput
  appKey: String
  imageUrls: [String!]
}

type SharePointSiteInfo {
  siteUrl: String!
  folderRelativeUrl: String!
  listUrl: String
}

type SharepointIds {
  siteId: String!
  driveId: String!
  driveItemId: String!
}

enum MessageExtensionCommandContextType {
  Compose
  Commandbox
  Message
}

type MessageExtensionParameter {
  name: String
  description: String
  title: String
  inputType: MessageExtensionInputType
  value: String
  choices: [MessageExtensionParameterChoice!]
}

input MessageExtensionParameterInput {
  name: String
  description: String
  title: String
  inputType: MessageExtensionInputType
  value: String
  choices: [MessageExtensionParameterChoiceInput!]
}

union Dimension = DimensionInFloat | DimensionInString

type DimensionInFloat {
  value: Float
}

type DimensionInString {
  value: String
}

type MessageExtensionCommandTaskInfo {
  title: String
  height: Dimension
  width: Dimension
  url: String
}

input MessageExtensionCommandTaskInfoInput {
  title: String
  height: String # Note: This should be like type "Dimension", but Input type union is not supported in GraphQL.
  width: String # Note: This should be like type "Dimension", but Input type union is not supported in GraphQL.
  url: String
}

enum MessageExtensionInputType {
  Text
  Textarea
  Number
  Date
  Time
  Toggle
  Choiceset
}

type MessageExtensionParameterChoice {
  title: String
  value: String
}

input MessageExtensionParameterChoiceInput {
  title: String
  value: String
}

type WebApplicationInfo {
  id: String
  resource: String
  appKey: String
  applicationPermissions: [String!]
}

input WebApplicationInfoInput {
  id: String
  resource: String
  appKey: String
  applicationPermissions: [String!]
}

enum MeetingReactionType {
  like
  heart
  laugh
  surprised
  applause
}

enum GestureReactionType {
  like
  heart
  applause
  raisehand
}

enum GestureReactionStatus {
  Init
  Cancel
  Complete
}

type ScheduledMember {
  memberId: String
  startTime: String
  endTime: String
}

type TeamTag {
  tagId: ID!
  tagName: String
  memberCount: Int
  tagType: String
  scheduledMembers: [ScheduledMember!]
  source: String
  version: Int
}

type TagCard {
  tagId: ID!
  tagName: String
  memberIds: [ID!]
  memberCount: Int
  tagDescription: String
  tagType: String
  currentMemberIsPartOfTag: Boolean
  scheduledMembers: [ScheduledMember!]
  source: String
  version: Int
  deletedDateTimeUtc: String
}

enum UserRoleInEmergencyCall {
  Caller
  SecurityDesk
}

type EmergencyCallInfo {
  myRoleInEmergencyCall: UserRoleInEmergencyCall
  callerLocation: String
  callerNumber: String
  emergencyCalleeMri: String
  chatExists: Boolean
}

"""
SelfCapabilities represents the local user's ability to perform an action in the call.
"""
type SelfCapabilities {
  canUnmuteSelf: Boolean
  canMuteOthers: Boolean
}

type ConsultContext {
  consultorName: String
  consulteeName: String
  consultingWith: UserRoleInConsultCall
  canTransfer: Boolean
  subjectTeamsCallId: ID
}

enum UserRoleInConsultCall {
  admin
  boss
  endUser
}

enum HolographicDeviceType {
  None
  HoloLens
  Android
  iOS
  HoloLensGuides
  MeshApp
  Other
}

enum MeetingPanelLocation {
  ProducerScreen
  ContributorScreen
  CallHealthScreen
}

enum CallHealthState {
  NotAvailable
  Green
  Amber
  Red
}

type CallingConversationState {
  isChatAvailable: Boolean!
  title: String
  isPrivateChannel: Boolean
  meetingInformation: MeetingInformation
  isUserMember: Boolean
  tenantId: String
  isOneOnOne: Boolean
  hasFederatedUser: Boolean
  substrateGroupId: String
  chatSubType: ChatSubType
  isMembersThresholdExceeded: Boolean
}

type BreakoutRoomsParticipantInControl {
  id: ID!
  userId: ID!
  participantId: ID!
}

type BreakoutRoomParticipant {
  upn: String
  mri: String!
  objectId: String
  role: String
}

type RoomCoordinates {
  tenantId: String!
  organizerId: String!
  threadId: String!
  messageId: String!
  additionalMessageId: String
}

type ParticipantMainMeetingDetails {
  id: ID!
  assignedRoomName: String!
  showJoinRoomButton: Boolean!
}

type BreakoutRoomsDetails {
  id: ID!
  breakoutRooms: [BreakoutRoom!]!
}

type BreakoutRoom {
  coordinates: RoomCoordinates!
  roomName: String!
  sourceMeetingCoordinates: RoomCoordinates!
    @deprecated(reason: "This is old field that is not used on UI anymore")
  participants: [BreakoutRoomParticipant]
  restrictChatAccess: Boolean
    @deprecated(
      reason: "With assignment distribution we will get room status from IC3"
    )
  isOpened: Boolean
  meetingJoinUrl: String
  eTag: String
}

type BreakoutroomDetails {
  isBreakoutRoom: Boolean!
  isBreakoutRoomMain: Boolean!
  participantInControl: BreakoutRoomsParticipantInControl
  managerUserIds: [ID!]
  mainMeetingJoinUrl: String
  remainingRoomDuration: String
  additionalData: String
  isRoomAutoJoinEnabled: Boolean
  initializedAt: BigInt
  remainingRoomDurationMs: BigInt
  version: String
}

type MaskedIdentityDetails {
  isIdentityMasked: Boolean
  maskedIdSeqNumber: Int
  maskedId: String
}

type StagingRoomProperties {
  stagingRoomEnabled: Boolean
  eventActive: Boolean
  eventIsLoading: Boolean
  willLandInStagingRoom: Boolean
  willLandInGreenRoom: Boolean
}

type RTMPInProperties {
  rtmpEnabled: Boolean!
}

type VdiCapabilities {
  video: Boolean
  screenshare: Boolean
  appshare: Boolean
  hid: Boolean
  multimonitorscreenshare: Boolean
  remoteaudionotifications: Boolean
  compositedevices: Boolean
  multiwindow: Boolean
  datachannel: Boolean
  givecontrol: Boolean
  sharesystemaudio: Boolean
  backgroundeffects: Boolean
}

type VdiEnvSettings {
  configFilter: String
  isAvRemoted: Boolean
  mode: String
  provider: ScalarEnumString
}

enum VdiProvider {
  None
  Citrix
  VMware
  AVD
  Windows365
  CitrixSlimCore
  VMwareSlimCore
  AVDSlimCore
  Windows365SlimCore
}

enum VirtualDesktopInfrastructureConnectedState {
  None
  Connected
  Disconnected
  Local
  Unknown
}

enum WebinarAccessPolicy {
  None
  Everyone
  EveryoneInCompany
}

"""
Reprensents token type provided by office 365 services
"""
enum RegistrationOperationType {
  """
  Default type is get the registration information
  """
  GetRegistrationInformation
  """
  Enable registration during create event flow
  """
  CreateEventEnableRegistration
  """
  Enable registration during update flow
  """
  UpdateEventEnableRegistration
  """
  Disable Registration during update flow
  """
  UpdateEventDisableRegistration
  """
  Cancel/ Delete Event flow with removing registration
  """
  RemoveRegistration
}

"""
Represents Webinar registration info
"""
type WebinarRegistrationInfo {
  """
  Gets or sets Registration url.
  """
  registrationUrl: String
  """
  The access policy.
  """
  accessPolicy: WebinarAccessPolicy
  """
  Specifies the operation so that right validation and updates happen
  """
  operationType: RegistrationOperationType
  """
  Gets or sets the Webinar id
  """
  webinarId: ID
  """
  Gets or sets a flag that indicates if the webinar was created using template.
  """
  isTemplateBasedFlow: Boolean
}

input WebinarRegistrationInfoInput {
  registrationUrl: String
  accessPolicy: WebinarAccessPolicy
  operationType: RegistrationOperationType
  webinarId: ID
  isTemplateBasedFlow: Boolean
}

type UserLicenseDetailsBenefits {
  hasTeamsLicense: Boolean!
  maxMeetingDurationMinutes: Int!
  maxMeetingParticipants: Int!
  licensedProducts: [UserLicensedProduct]
}

type UserLicensedProduct {
  skuName: String
  skuId: String
}

type Query {
  _noop: String
  """
  @param teamId - the teamId for the team to load channels from.
  @param loadDeleted - if we should load deleted channels or active channels, defaults to false
  @param filter - filter to filter the channels by.
  @return - list of channels for the team with a display name containing the filter.
  """
  channels(teamId: ID!, loadDeleted: Boolean, filter: String): [Channel!]!
  """
  @param id - mri or email of the user being requested
  @param isMailAddress - if the id that was passed in is an email
  @param defaultName - if the user is not found, we add a default name to the unknown user
  @param scenarioId - the scenario being used to log this
  @param usersFromCallingRoster - All of the users from calling roster. This is passed in and JSON.stringified because we currently do not have callingRoster in TMP
  @return - user with the mri given
  """
  getUser(
    id: ID!
    isMailAddress: Boolean
    defaultName: String
    scenarioId: String
    usersFromCallingRoster: String
    callerInfo: String
  ): User
  """
  @param startDate - Start Date to fetch the events from
  @param endDate - End Date to fetch the events upto
  @param scenarioName - Current Active Scenario Name
  @return - list of calendar events from scheduling service
  """
  schedulingServiceCalendarEvents(
    startDate: DateTime!
    endDate: DateTime!
    scenarioName: String
  ): SchedulingServiceFilteredEvents
  """
  @param startDate - Start Date to fetch the events from
  @param endDate - End Date to fetch the events upto
  @param events - list of prefetched events
  @return - list of calendar events
  """
  calendarEventsV2PrefetchCache(
    startDate: ScalarEnumString!
    endDate: ScalarEnumString!
    events: [CalendarEventInput]!
  ): FilteredEvents
  """
  @return - list of all day bucket calendar events
  """
  allDayBucketEventsList: [AllDayEvents!]
  """
  @return - list of in day bucket calendar events
  """
  inDayBucketEventsList: [InDayEvents!]
  """
  @param calendarEvent - input calendar event
  @return CalendarEvent - output calendar event
  DEPRECATED - use getTypedCalendarEventV2
  """
  getTypedCalendarEvent(calendarEvent: CalendarEventInput): CalendarEvent
  """
  @param calendarEvent - input calendar event
  @param isDetailed - if detailed fields required
  @return TypedCalendarEvent - output calendar event
  """
  getTypedCalendarEventV2(
    calendarEvent: CalendarEventInput!
    isDetailed: Boolean!
  ): TypedCalendarEvent
  """
  @param threadId - the thread id to get the attendees for
  @return - list of attendees for the meeting
  """
  meetingAttendees(threadId: String!): [Attendee!]
  """
  @param threadId - the id of the thread (chat) of the related action items
  @param callId - the id of the call of the related action items
  @param organizerId - the id of the meeting organizer (objectId@tenantId)
  @return list of ActionItem objects
  """
  actionItems(threadId: ID!, callId: ID, organizerId: ID!): [ActionItem!]!
  """
  @param - teams call id
  @return - list of currently attendee restricted modalities for the provided call
  """
  callAttendeeRestrictedModalities(
    teamsCallId: ID!
  ): [AttendeeRestrictableModality!]!
  """
  @returns - list of current calls
  """
  calls: [Call!]
  """
  @return the list of recent and exchange ppt files for share tray
  @param - teams call id
  DEPRECATED - use callPptFiles1 instead
  """
  callPptFiles(callId: ID!): [PptSharingContent!]
  """
  @param objectUrl - Complete sharepoint URL of file
  @param actionType - Wopi Action Type
  @param isVroomRequired - To decide whether on not to make driveItem call
  @return - Metadata for the given file URL
  """
  fileOpenInitParams(
    objectUrl: String
    actionType: String!
    isVroomRequired: Boolean!
  ): FileOpenInitParams!
  """
  @param objectUrl - Complete sharepoint URL of file
  @return - List metadata for the given file URL
  """
  fileListMetadata(objectUrl: String!): ListMetadata
  """
  @param input - File transform input params
  """
  fileTransform(input: FileTransformInput!): FileTransformOutput
  """
  @param objectUrl - Complete sharepoint URL of file
  @return - File thumbnail URL
  """
  fileThumbnailUrl(objectUrl: String!): String
  """
  @param callId - the call identifier
  @return true if conversation in different tenant, otherwise false
  """
  conversationInDifferentTenant(callId: ID!): Boolean
  """
  @param conversationId - the id of the conversation
  @param messageId - the id of the message
  @param sentTime - the time the message was sent
  @return group chat from the conversation
  """
  groupChat(
    conversationId: ID!
    messageId: ID!
    sentTime: String
  ): SearchReplyChain
  """
  DEPRECATED - use callRecordingsInfo instead
  """
  callRecordings(
    tenantId: ID!
    userId: ID!
    threadId: ID!
    messageId: ID!
  ): [CallRecording!]!
  """
  Get Personal Site Information For File Upload
  @return SharePoint site information - Return Share Point site information containing siteUrl
  """
  personalSiteInfo: SharePointSiteInfo
  """
  DEPRECATED move to be part of Call type
  """
  emergencyCallInfo(teamsCallId: ID!): EmergencyCallInfo
  """
  Get the state of video effect
  @param teamsCallId - the id (teamsCallId) of the call
  @param effect - the video effect
  @return video effect state
  """
  videoEffectState(
    teamsCallId: ID!
    effect: VideoEffect!
  ): VideoEffectStateType!
  """
  Get bot file download url
  @param objectUrl - user's file object url
  @return downloadurl - download url to send to the bot
  """
  getBotFileDownloadUrl(objectUrl: String!): String
  """
  Get call screen view options
  @param teamsCallId - the id of the call
  @return - CallScreenViewOptions
  """
  callScreenViewOptions(teamsCallId: ID!): CallScreenViewOptions
  """
  Get prejoin initialization state
  @return - prejoin initialization state
  """
  prejoinInitState: PrejoinInitState!
  """
  Get emergency phone number from number
  @return result containing emergency phone number and encoded content
  [todo] Move back to client: should port this emergencyService logic over to TMP, instead of relying on Angular
  https://domoreexp.visualstudio.com/MSTeams/_workitems/edit/800589
  """
  emergencyPhoneNumber(
    numberWithoutCountryCode: String!
    numberPortion: String!
  ): EmergencyPhoneNumberResult

  """
  Get the calling conversation state
  """
  callingConversationState(
    conversationId: ID!
    replyChainId: String
  ): CallingConversationState!
  """
  Check if download attendance report tile should show up in meeting recap page
  @param - thread id
  """
  hasAttendanceReport(threadId: ID!): Boolean!
  """
  Check if coach tab should show up in meeting detail page in calendar
  """
  hasCoachReport(threadId: ID!, messageId: ID): Boolean!
  """
  Check if latest coach report matches the given callId
  """
  latestCoachReportMatchCallId(
    threadId: ID!
    callId: ID!
    messageId: ID
  ): Boolean!
  """
  Check if meeting notes tile should show up in meeting recap page
  @param privateMeeting - check if meeting is private
  @param threadId - id for the thread
  @param messageId - id for the message
  """
  isMeetingNotesLinkAvailable(threadId: ID!, messageId: ID!): Boolean!
  """
  @param threadId - id for the thread
  @param messageId - id for the message
  @return boolean flag to indicate available meeting content recording
  """
  hasRecording(threadId: ID!, messageId: ID!): Boolean!
  """
  @param threadId - id for the thread
  @param messageId - id for the message
  @return a list of recording message ids
  """
  getRecordingMessageIds(threadId: ID!, messageId: ID!): [String]
  """
  @param threadId - id for the thread
  @param messageId - id for the message
  @return the latest recording
  """
  getLatestRecording(threadId: ID!, messageId: ID!): CallRecording
  """
  @param threadId - id for the thread
  @param messageId - id for the message
  @return time latest recording was updated
  """
  getLastUpdatedAt(threadId: ID!, messageId: ID!): String
  """
  @return the list of recent ppt Files for casting content
  """
  castPptFiles: [PptSharingContent!]
  """
  Query to check current coach status.
  @param teamsCallId
  """
  currentCoachStatus(teamsCallId: ID!): CoachStatusEvent!
  """
  Query to check value of muteNotificationsDuringMeeting user setting.
  """
  muteNotificationsDuringMeetings(teamsCallId: ID!): MuteNotificationsResponse!
  """
  Query to get consumer license details.
  """
  consumerLicenseDetailsBenefits(
    onDemandFetch: Boolean
  ): UserLicenseDetailsBenefits
  """
  @param threadId - id of thread
  @param pageNumber - pageNumber of query
  @param totalFiles - totalFiles of data
  @param params - input params
  @return - FilesListResult for the thread id
  """
  p2pFilesList(
    threadId: ID!
    pageNumber: Int!
    totalFiles: Int!
    params: P2PFilesInput!
  ): FilesListResult!
  """
  @param threadId - id of thread
  @param pageNumber - pageNumber of query
  @param isLimited - if we only want the first few files for Chat Info Pane L1 view
  @return - FilesListResult for the thread id
  """
  p2pFilesChatInfoPane(
    threadId: ID!
    pageNumber: Int!
    isLimited: Boolean
  ): FilesListResult!
  """
  Get whiteboard URL for a specific meeting. Has two effects depending on whether Fluid whiteboards are enabled
  - If Fluid whiteboards aren't enabled, goes to the Whiteboard service to get or create meeting whiteboard URL
  - If Fluid whiteboards are enabled, goes to Team MT to get a cached board URL or a default "landing page" URL
  @param threadId - thread id
  @param messageId - message id
  @param organizerId - organizer id
  @param tenantId - tenant id
  @param title - title
  @param initiatorId - initiator id
  @param isGcc - whether this user is a GCC user
  @param isAnnotation - whether whiteboard is being shared in an annotation scenario
  @return whiteboard meeting URL
  """
  getWhiteboardUrl(
    threadId: ID!
    messageId: ID!
    organizerId: ID!
    tenantId: ID!
    title: String!
    initiatorId: String!
    isGcc: Boolean!
    isAnnotation: Boolean!
  ): String!
  """
  Check if the whiteboard tab is enabled
  @param conversationTenantId - tenant ID for the current conversation
  @return boolean indicating whether whiteboard tab is enabled
  """
  whiteboardTabEnabled(conversationTenantId: ID!): Boolean!
  """
  Get cloud storage folders contents
  @param externalfolderCombinedData - external folder detail
  @param providerCode - cloud storage folder provider code
  @return CommonExternalFolderData content
  """
  cloudStorageFolderContentsExternalFolderChannel(
    externalFolderChannelInput: ExternalFolderChannelInput!
    providerCode: String!
  ): [CommonExternalFolderData]!
  """
  Get cloud storage folders contents
  @param externalfolderCombinedData - external folder detail
  @param providerCode - cloud storage folder provider code
  @return CommonExternalFolderData content
  """
  cloudStorageFolderContentsCommonExternalDto(
    commonExternalFolderDataInput: CommonExternalFolderDataInput!
    providerCode: String!
  ): [CommonExternalFolderData]!
  """
  Get external cloud storage providers
  @param excludeUserAddedProviders - should we exclude added external user added cloud storage Providers (i.e. DROPBOX, BOX)
  @return list of ExternalProvider details
  """
  externalProviders(
    excludeUserAddedProviders: Boolean!
  ): [ExternalCloudStorageProvider]!

  """
  Query to fetch VDI mode
  @returns VDI mode
  """
  vdiMode: String

  """
  Query to fetch VDI version information
  @returns VDI version information
  """
  vdiVersionInfo: String

  """
  Query to get streamDetail for streaming client or user connected to streaming mode
  @id is the thread id for the meeting
  """
  streamDetails(id: ID!): StreamDetailsInfo

  """
  Query to get OS information
  @returns OS information
  """
  osInfo: OSInfo

  """
  Query to get last call information
  @returns last call information
  """
  lastCallInfo: LastCallInfo
}

type LastCallInfo {
  callId: String
  wasPoppedOut: Boolean
  isBroadCast: Boolean
  slimcoreVesrion: String
  tsCallingVersion: String
}

type OSInfo {
  id: ID!
  cores: String
  cpuarchitecture: String
  cpuspeed: String
  cpumodel: String
  family: String
  name: String
  totalMemory: String
  version: String
}

type AddCloudStorageFolder {
  isFolderAdded: Boolean!
  cloudStorageFolders: [ExternalFolderChannel]!
}

type DeleteCloudStorageFolder {
  isFolderDeleted: Boolean!
  cloudStorageFolder: ExternalFolderChannel!
}

type ExternalFolderChannel {
  id: ID!
  folderId: String!
  providerType: FilesProviderType!
  title: String!
  providerCode: String!
  ownerDisplayName: String!
  siteUrl: String
  serverRelativeUrl: String
  libraryType: String
  accessType: String
}
enum FilesProviderType {
  Sharepoint
  WOPI
  Google
  OneDrive
  Recent
  Aggregate
  FileSystem
  Search
  AllFiles
  SharedWithMe
}
type CommonExternalFolderData {
  id: ID!
  lastModifiedTime: String!
  size: Int!
  objectUrl: String!
  accessToken: String
  title: String!
  isSubdirectory: Boolean!
  type: String!
}
input ExternalFolderChannelInput {
  id: ID!
  folderId: String!
  providerType: FilesProviderType!
  title: String!
  providerCode: String!
  ownerDisplayName: String!
  siteUrl: String
  serverRelativeUrl: String
  libraryType: String
  accessType: String
}
input SharepointRecentSiteFolderInput {
  url: String!
  title: String!
  siteUrl: String
  serverRelativeUrl: String
}
input CommonExternalFolderDataInput {
  id: ID!
  lastModifiedTime: String!
  size: Int!
  objectUrl: String!
  accessToken: String
  title: String!
  isSubdirectory: Boolean!
  type: String!
}
"""
Details of external cloud storage Providers (i.e. DROPBOX, BOX)
RemoteImage: External Cloud Storage Thumbnail details
"""
type ExternalCloudStorageProvider {
  name: ID!
  description: String!
  thumbnails: [RemoteImage!]!
  navigationType: FilesNavigationType!
  providerType: FilesProviderType!
  providerCode: ExternalCloudStorageProviderCode
}
enum ExternalCloudStorageProviderCode {
  DROPBOX
  BOX
  SHAREFILE
  GOOGLEDRIVE
  EGNYTE
  SharePoint
}
enum FilesNavigationType {
  Recent
  Aggregate
  Personal
  Teams
  Channels
  Downloads
  PersonalWopi
  PersonalGoogle
  CustomSpo
  SharedWithMe
  Chats
}
input SharePointFile {
  siteUrl: ID!
  objectId: String!
  objectUrl: String!
  openInWindowFileUrl: String!
  title: String!
  isFolder: Boolean!
  serverRelativeUrl: String!
  lastModifiedByUser: SharePointFileFilesEntityUser!
  lastModifiedTime: String!
  sentByUser: SharePointFileFilesEntityUser!
  createdByUser: SharePointFileFilesEntityUser!
  createdTime: String!
  size: Int!
  type: String!
  spItemUrl: String
  libraryType: SharePointFileSpecialDocumentLibraryType
  accessType: SharePointFileDocumentLibraryAccessType
  etag: String
  remoteItem: String
  listUrl: String
  siteId: String
}
type SharePointFileOutput {
  siteUrl: ID!
  objectId: String!
  objectUrl: String!
  openInWindowFileUrl: String!
  title: String!
  isFolder: Boolean!
  serverRelativeUrl: String!
  lastModifiedByUser: SharePointFileFilesEntityUserOutput!
  lastModifiedTime: String!
  sentByUser: SharePointFileFilesEntityUserOutput!
  createdByUser: SharePointFileFilesEntityUserOutput!
  createdTime: String!
  size: Int!
  type: String!
  spItemUrl: String
  libraryType: SharePointFileSpecialDocumentLibraryType
  accessType: SharePointFileDocumentLibraryAccessType
  etag: String
  remoteItem: String
  listUrl: String
  siteId: String
}
input SharePointFileFilesEntityUser {
  displayName: String!
  email: String!
  mri: String!
}
type SharePointFileFilesEntityUserOutput {
  displayName: String!
  email: String!
  mri: String!
}
enum SharePointFileSpecialDocumentLibraryType {
  classMaterials
}
enum SharePointFileDocumentLibraryAccessType {
  readonly
}
input AnnotationToolbarPositionInput {
  x: Float!
  y: Float!
  width: Float!
  height: Float!
}
type Mutation {
  _noop: String
  """
  Clears the attendee modality restrictions for all Attendees in the provided Meeting
  @return Boolean as graphql doesn't support void types
  """
  clearAttendeeRestrictions(teamsCallId: ID!): Boolean!
  """
  @param channelId - Channel ID to update shown setting
  @param isShown - If the channel should be shown
  @return - boolean indicating if the request succeeded
  """
  updateShowChannel(channelId: ID!, isShown: Boolean!): Boolean
  """
  @param channelId - Channel ID to update shown by default setting
  @param isShownByDefault - If the channel should be shown by default
  @return - boolean indicating if the request succeeded
  """
  updateShowChannelByDefault(
    channelId: ID!
    isShownByDefault: Boolean!
  ): Boolean
  """
  Updates the in-memory and the persistence cache with the given users
  @param userProfiles: [User]
  @param isShortProfile: Boolean
  @param scenarioId - the scenario being used to log this
  """
  updateCachedProfilesByMri(
    userProfiles: [UserInputCSA!]!
    isShortProfile: Boolean
    scenarioId: String
  ): Boolean
  """
  Updates the in memory and peristence cache with the given user
  @param userProfileObject - The user object
  @param removeExistingProfile - remove existing profile if set to true (to wipe out unknown profile)
  @param scenarioId - the scenario being used to log this
  """
  updateCachedUserProfile(
    userProfileObject: UserInputFull!
    removeExistingProfile: Boolean
    scenarioId: String
  ): Boolean
  """
  @param event - event id of the meeting
  @return - true if successfully manipulated
  """
  cacheUpdate(eventId: String!): Boolean
  """
  @param callId - incoming call's callId
  @param acceptOptions - options to join the call
  @return - joined call
  """
  acceptCall(callId: ID!, acceptOptions: AcceptOptions): Call
  """
  @param callId - callId to which we're adding participant
  @param userId - userId of participant
  @return - the call
  DEPRECATED - use addParticipant1
  """
  addParticipant(callId: ID!, userId: ID!): Call
  """
  @param callId - callId for which we're removing participant
  @param participantId - participant to be removed
  @return - the call
  DEPRECATED - use removeParticipant1 instead
  """
  removeParticipant(callId: ID!, participantId: ID!): Call
  """
  @param callId - callId to which we're admitting participant from lobby
  @param participantId - id of participant to be admittted
  @return - the call
  DEPRECATED - use admitParticipant1 instead
  """
  admitParticipant(callId: ID!, participantId: ID!): Call
  """
  @param callId - callId to which we're admitting participants from lobby
  @param participantIds - array of ids of participants to be admitted
  @return - the call
  DEPRECATED - use admitAllParticipants1 instead
  """
  admitAllParticipants(callId: ID!, participantIds: [ID!]!): Call
  """
  @param callId - callId for which we're muting participant
  @param participantId - participant to be muted
  @return - the participant
  DEPRECATED - use muteParticipant1 instead
  """
  muteParticipant(callId: ID!, participantId: ID!): Participant
  """
  @param callId - callId for which we're muting the participants
  @return - the call
  DEPRECATED - use muteAllParticipants1 instead
  """
  muteAllParticipants(callId: ID!): Call
  """
  update info about right panel content - temporary solution
  @param content - right side panel content
  """
  setPanelContent(content: String!): Boolean
  """
  @param convId - conversation id with user to be transferred
  @return - conversation that was used for consultation
  """
  transferChatConsultation(convId: ID!): Conversation
  """
  DEPRECATED - use createCompositorV2 instead
  @param teamsCallId - call id on which we want to start the stream
  @param compositorId - id of the compositor
  @param width - width
  @param height - height
  @param disableNativeCompositor - if true, will not use native rendering
  @return - bufferName of the stream that was started
  """
  createCompositorNew(
    teamsCallId: ID!
    compositorId: ID!
    width: Int!
    height: Int!
    x: Int
    y: Int
    isSharingCompositor: Boolean
    disableNativeCompositor: Boolean
  ): StreamMetadataWithConfig
  """
  @param callId - callId which we want to lock for XL meetings
  """
  lockXLMeeting(callId: ID!): Call
  """
  @param teamsCallId - teamsCallId on which we want to toggle spotlight
  """
  toggleSpotlight(teamsCallId: ID!): Call
  """
  @param teamsCallId - teamsCallId on which we want to toggle end of meeting alert
  """
  toggleEndOfMeetingAlert(teamsCallId: ID!): Boolean
  """
  @param teamsCallId - teamsCallId on which we want to toggle the video effect
  @param effect - the video effect
  """
  toggleVideoEffect(teamsCallId: ID!, effect: VideoEffect!): Call
  """
  @param teamsCallId - teamsCallId on which we want to take a snapshot
  @return Base64 encoded image of the snapshot
  """
  takeContentCameraSnapshot(teamsCallId: ID!): String
  """
  start outgoing file sharing for a given call
  @param callId: The call id for which we need to start file sharing
  @param pptSharingContent: The ppt file that need to be shared
  @return - boolean
  DEPRECATED - use startFileSharing1 instead
  """
  startFileSharing(
    callId: ID!
    pptSharingContent: PptSharingContentInput!
  ): Boolean
  """
  stop Invision WB sharing
  @param teamsCallId: the call id containing the sharing session
  @return - true if operation succeeded
  """
  stopInvisionWhiteboardSharing(teamsCallId: ID!): Boolean!
  """
  stop active content sharing session
  @param teamsCallId: The call id for which we need to start content sharing
  @return - boolean
  """
  stopContentSharing(teamsCallId: ID!): Boolean!
  """
  updates exisiting scheduling service event
  @param schedulingServiceEvent scheduling service event update payload
  @return - boolean
  """
  updateSchedulingServiceEvent(
    schedulingServiceEvent: SchedulingServiceEventUpdateInput!
  ): Boolean
  """
  Deprecated use startClosedCaptions
  starts closed caption for the call
  @param callId: id of the call
  @return - boolean that specify if the mutation was successfull
  """
  startClosedCaption(callId: ID!): Boolean
  """
  Deprecated stopClosedCaptions
  stops closed caption for the call
  @param callId: id of the call
  @return - boolean that specify if the mutation was successfull
  """
  stopClosedCaption(callId: ID!): Boolean
  """
  downloads transcript in the requested format
  @param url: SMIS url to query for the download
  @param format: format to download
  @return - boolean indicating if mutation was successful
  """
  downloadTranscript(url: String!, format: TranscriptDownloadFormat!): Boolean
  """
  deletes provided transcript
  @param url: SMIS url for the transcript to delete
  @param threadId: threadId for control message delete
  @param messageId: messageId for control message delete
  @return - boolean indicating if mutation was successful
  """
  deleteTranscript(url: String!, threadId: String, messageId: String): Boolean
  """
  downloads transcript in the requested format
  @param threadId: threadId associated with the meeting
  @param transcriptId: scopeId of the transcript
  @param messageId: threadMessageId of the control message
  @param format: format to download
  @return - boolean indicating if mutation was successful
  """
  downloadTranscriptArtifact(
    threadId: String!
    transcriptId: String!
    messageId: String!
    format: String!
  ): Boolean
  """
  deletes provided transcript
  @param threadId: threadId associated with the meeting
  @param transcriptId: scopeId of the transcript
  @param messageId: threadMessageId of the control message
  @return - boolean indicating if mutation was successful
  """
  deleteTranscriptArtifact(
    threadId: String!
    transcriptId: String!
    messageId: String!
  ): Boolean
  """
  @param callId - callId on which we want to toogle background blur
  """
  toggleBackgroundBlur(callId: ID!): Call
  """
  Triggers the download of the desktop app
  """
  downloadDesktopApp(context: String!): Boolean

  """
  mutation for card cache operations over CDL
  @param type - type of cache operation
  @param value - data/value to be used for operation
  @return CardCacheOperationResponse - object that contains cached data
  """
  cardCDLCacheOperation(
    type: CardCacheOperationType!
    key: String!
    value: String
    version: String
  ): CardCacheOperationResponse
  """
  @param effect - which effect to apply
  @param context - in which context this operation is executed (for logging)
  @return boolean - true if operation was successful
  """
  setWhiteboardDeviceVideoEffect(
    effect: VideoEffect!
    context: String!
  ): Boolean
  """
  mute meeting coach notifications for the call
  @param teamsCallId: id of the call
  @return - boolean that specify if the mutation was successfull
  """
  muteCoach(teamsCallId: ID!): Boolean!
  """
  mute notifications during a meeting or call
  @param isNotificationMuted: whether to mute notifications during current call
  @param callId: id of the call
  @return - boolean that specify if the mutation was successful
  """
  muteNotificationsDuringMeeting(
    isNotificationMuted: Boolean!
    teamsCallId: ID!
  ): MuteNotificationsResponse!
  """
  restarts a broadcast
  @param teamsCallId - the associated teams call id
  @return boolean that specify if the mutation was successful
  """
  restartBroadcast(teamsCallId: ID!): Boolean!
  """
  stops holographic interaction
  @param teamsCallId - teamsCallId of the call
  @param participantId - the participant whose stream is being interacted with
  @return true if interaction successfully stopped
  """
  stopHolographicInteraction(teamsCallId: ID!, participantId: ID!): Boolean!
  """
  Add contact to buddy group
  @param mri - user mri, empty will show adding new contact dialog
  @param buddyGroupId - id of the buddy group for which the contact will be added
  @return Boolean as graphql doesn't support void types
  """
  addContactToBuddyGroup(mri: String!, buddyGroupId: String!): Boolean!
  """
  Send UFD alert for breakout room timer expiration.
  @param teamsCallId - Call ID.
  @return Boolean as graphql doesn't support void types
  """
  sendBreakoutRoomTimerExpireUfdAlert(teamsCallId: ID!): Boolean!
  """
  Send dialog alert for breakout room timer expiration.
  @param teamsCallId - Call ID.
  @return Boolean as graphql doesn't support void types
  """
  sendBreakoutRoomTimerExpireDialogAlert(teamsCallId: ID!): Boolean!
  """
  Checks media permissions and returns face enrollment stream
  @return Media stream for video
  """
  startFaceEnrollmentStream(cameraId: String!): Boolean!
  """
  stops face enrollment stream
  @return Boolean as graphql doesn't support void types
  """
  stopFaceEnrollmentStream: Boolean!
  """
  @param threadId - the id of the thread (chat) of the related action items
  @param callId - the id of the call of the related action items
  @param organizerId - the id of the meeting organizer (objectId@tenantId)
  @param actionItem - the action item to be created
  @returns The ActionItem that was created
  """
  createActionItem(
    threadId: ID!
    callId: ID
    organizerId: ID!
    actionItem: ActionItemInput
  ): ActionItem
  """
  @param threadId - the id of the thread (chat) of the related action items
  @param callId - the id of the call of the related action items
  @param organizerId - the id of the meeting organizer (objectId@tenantId)
  @param actionItem - the action item to be updated
  @returns ActionItemUpdateResponse - indicates whether the action item was updated and contains the udpated actionItem
  """
  updateActionItem(
    threadId: ID!
    callId: ID
    organizerId: ID!
    actionItem: ActionItemInput
  ): ActionItemUpdateResponse
  """
  @param threadId - the id of the thread (chat) of the related action items
  @param callId - the id of the call of the related action items
  @param organizerId - the id of the meeting organizer (objectId@tenantId)
  @param actionItemId - the id of the action item that needs to be deleted
  @returns Boolean - indicates whether the deletion completed successfully or not
  @return boolean as GraphQL does not have void type
  """
  deleteActionItem(
    threadId: ID!
    callId: ID
    organizerId: ID!
    actionItemId: String
  ): Boolean
  """
  Trigger the download atendance report action in meeting recap page
  @param - thread id
  """
  downloadAttendanceReport(threadId: ID!): Boolean
  """
  Trigger the download registration report action
  @param threadId
  @param webinarId
  """
  downloadRegistrationReport(threadId: ID!, webinarId: ID!): Boolean!
  """
  Discard the chat with the given id
  @param convId - chat id
  """
  discardChat(convId: ID!): Boolean
  """
  Sends request to deactivate breakout room Alert
    @param alertType - name of the alert to deactivate
  """
  deactivateBreakoutRoomAlert(alertType: AlertType!): Boolean

  """
  Mutation to CDL Worker to notify that deferred non-essential syncing on startup can start
  """
  notifyWorkerSyncCanStart: Boolean

  """
  Mutation to CDL Worker to notify that active context is changing
  """
  notifyActiveContextChangedToCDLWorker(
    activeContextId: ID!
    activeContextType: ActiveContextType!
  ): Boolean
  """
  Open cloud storage folder
  @param item - folder detail
  @param providerCode - cloud storage folder provider code
  @param fileOpenPreference - file open preference
  @ret is it a sucess or not
  """
  openCloudStorageFile(
    commonExternalFolderDataInput: CommonExternalFolderDataInput!
    externalFilesProviderCode: String!
    fileOpenPreference: String!
  ): CommonExternalFolderData!

  """
  Copy or Move Channel Files for Common External Folder
  @param selectedFiles - selected files
  @param providerCode - cloud storage folder provider code
  @param destinationFolder - destination folder
  @param destinationProviderCode - destination cloud storage folder provider code
  @param isMove - it's a move operation
  @ret list of files which are copied or moved
  """
  copyMoveFilesCommonExternalFolder(
    selectedFiles: [CommonExternalFolderDataInput]!
    providerCode: ExternalCloudStorageProviderCode!
    destinationFolder: CommonExternalFolderDataInput
    destinationProviderCode: ExternalCloudStorageProviderCode
    isMove: Boolean
  ): [CommonExternalFolderData]!

  """
  Copy or Move Channel Files for SharePointFile
  @param selectedFiles - selected files
  @param providerCode - cloud storage folder provider code
  @param destinationFolder - destination folder
  @param destinationProviderCode - destination cloud storage folder provider code
  @param isMove - it's a move operation
  @ret list of files which are copied or moved
  """
  copyMoveFilesSharePointFile(
    selectedFiles: [SharePointFile]!
    providerCode: ExternalCloudStorageProviderCode!
    destinationFolder: SharePointFile
    destinationProviderCode: ExternalCloudStorageProviderCode
    isMove: Boolean
  ): [SharePointFileOutput]!
  """
  Copy or Move Channel Files for Common External Folder to SharePoint type
  @param selectedFiles - selected files
  @param providerCode - cloud storage folder provider code
  @param destinationFolder - destination folder
  @param destinationProviderCode - destination cloud storage folder provider code
  @param isMove - it's a move operation
  @ret list of files which are copied or moved
  """
  copyMoveFilesCommonExternalFolderToSharePoint(
    selectedFiles: [CommonExternalFolderDataInput!]!
    providerCode: ExternalCloudStorageProviderCode!
    destinationFolder: SharePointFile
    destinationProviderCode: ExternalCloudStorageProviderCode
    isMove: Boolean
  ): [CommonExternalFolderData!]!
  """
  Copy or Move Channel Files for SharePointFile to Common External Folder type
  @param selectedFiles - selected files
  @param providerCode - cloud storage folder provider code
  @param destinationFolder - destination folder
  @param destinationProviderCode - destination cloud storage folder provider code
  @param isMove - it's a move operation
  @ret list of files which are copied or moved
  """
  copyMoveFilesSharePointFileToCommonExternalFolder(
    selectedFiles: [SharePointFile!]!
    providerCode: ExternalCloudStorageProviderCode!
    destinationFolder: CommonExternalFolderDataInput
    destinationProviderCode: ExternalCloudStorageProviderCode
    isMove: Boolean
  ): [SharePointFileOutput!]!
  """
  Start click-through mode for annotation
  @param input -  annotationToolbarPosition : Annotation Toolbar position
  @return -  Boolean value whether clickthrough mode for annotation started or not.
  """
  startAnnotationClickthrough(
    annotationToolbarPosition: AnnotationToolbarPositionInput
  ): Boolean!
  """
  Stop Click-through mode for annotation
  @return -  Boolean value whether clickthrough mode for annotation stopped or not.
  """
  stopAnnotationClickthrough(teamsCallId: ID!): Boolean!
}

"""
Task 474709: we need to to clean and group all related subscriptions in N* into their specific union streams at the earliest.
"""
type Subscription {
  _noop: String
  """
  Subscription to listen for changes to AttendeeRestrictions, aka Hard Mute
  DEPRECATED - use callParticipantAudioRestrictionsChangedEvent instead for audio and callParticipantVideoRestrictionsChangedEvent for video
  """
  callAttendeeRestrictionsChangedEvent(
    teamsCallId: ID!
  ): [AttendeeRestrictableModality!]!
  """
  Subscription to listen for changes to AttendeeRestrictions for specific participants that differ from everyone else in a meeting, aka Hard Mute
  DEPRECATED - use callParticipantAudioRestrictionsChangedEvent instead for audio and callParticipantVideoRestrictionsChangedEvent for video
  """
  callParticipantRestrictionsChangedEvent(
    teamsCallId: ID!
  ): [CallParticipantRestrictions!]!
  actionStatusEvent(
    conversationId: ID
    replyChainId: String
  ): [ActionStatusEvent!]!
  contentSharingAddedEvent(teamsCallId: ID!): ContentSharingAdded!
  """
  Deprecated use - closedCaptionsStatusEvent
  """
  callClosedCaptionChangedEvent(teamsCallId: ID!): ClosedCaptionStateChanged
  systemAudioSupportChanged(teamsCallId: ID!): SystemAudioSupport!
  """
  Event raised if call block list was changed from the settings pane
  """
  callBlockingListUpdatedEvent: Boolean
  overflowRoomFoundForIntentEvent(callingIntentId: ID!): String
  coachResultEvent(teamsCallId: ID!): CoachResult!
  """
  Listen to ultrasound detected during prejoin event
  """
  ultrasoundDetectedEvent(callingIntentId: ID!): Boolean!
  """
  Subscription to listen for call screen view options change
  """
  callScreenViewOptionsChangedEvent(teamsCallId: ID!): CallScreenViewOptions
  """
  Subscription to listen for prejoin initialization state changes
  """
  prejoinInitStateChangedEvent: PrejoinInitState!
  """
  @conversationId - Conversation Id of the conversation for which the event is raised
  @activitiesFromWorker - Fetches channel activity properties from worker when the shared channel & team fragment is used (More details here #2676034)
  """
  teamsAndChannelsUpdateEvent(
    conversationId: ID
    activitiesFromWorker: Boolean!
  ): TeamsAndChannelsUpdateEvent!
  teamAndChannelListUpdateEvent(
    conversationIds: [ID!]!
    activitiesFromWorker: Boolean!
  ): TeamAndChannelListUpdateEvent!
  """
  Subscription to listen to changes in muteNotificationsDuringMeeting user setting
  """
  muteNotificationsDuringMeetingEvent(
    teamsCallId: ID!
  ): MuteNotificationsResponse
}

input SchedulingServiceChatContextInput {
  additionalMessageId: String
  messageId: Int
  threadId: String!
}

input SchedulingServiceMeetingLinksInput {
  join: String!
  update: String!
}

input SchedulingServiceMeetingViewsInput {
  html: String!
}

enum MessageImportanceInGraphFormat {
  normal
  high
  urgent
}

enum ActiveContextType {
  chat
  channel
}

enum UserIdentityType {
  aadUser
  onPremiseAadUser
  anonymousGuest
  federatedUser
}

enum ApplicationIdentityType {
  aadApplication
  bot
  tenantBot
  office365Connector
  webhook
}

input MessageActionPayloadUser {
  """
  Possible values include: 'aadUser', 'onPremiseAadUser','anonymousGuest', 'federatedUser'
  """
  userIdentityType: UserIdentityType
  """
  The id of the user.
  """
  id: String
  """
  The plaintext display name of the user
  """
  displayName: String
}

input MessageActionPayloadApp {
  """
  The type of application. Possible values include: 'aadApplication', 'bot',
  'tenantBot', 'office365Connector', 'webhook'
  """
  applicationIdentityType: ApplicationIdentityType
  """
  The id of the application
  """
  id: String
  """
  The plaintext display name of the application
  """
  displayName: String
}

input MessageActionPayloadDevice {
  """
  The id of the device
  """
  id: String
  """
  The plaintext display name of the device
  """
  displayName: String
}

enum ConversationIdentityType {
  team
  channel
}

input MessageActionPayloadConversation {
  """
  The type of conversation, whether a team or channel. Possible values include: 'team', 'channel'
  """
  conversationIdentityType: ConversationIdentityType
  """
  The id of the team or channel
  """
  id: String
  """
  The plaintext display name of the team or channel entity
  """
  displayName: String
}

input MessageActionPayloadFrom {
  device: MessageActionPayloadDevice
  """
  Represents details of the user
  """
  user: MessageActionPayloadUser
  """
  Represents details of the app
  """
  application: MessageActionPayloadApp
  """
  Represents details of the converesation.
  """
  conversation: MessageActionPayloadConversation
}

enum ContentType {
  html
  text
}

input MessageActionPayloadBody {
  """
  Type of the content. Possible values include: 'html', 'text'
  """
  contentType: ContentType
  """
  The content of the body
  """
  content: String
  """
  The text content of the body after stripping HTML tags
  """
  textContent: String
}

input MessageActionPayloadAttachment {
  """
  The id of the attachment
  """
  id: String
  """
  The type of the attachment
  """
  contentType: String
  """
  The url of the attachment, in case of an external link.
  """
  contentUrl: String
  """
  The content of the attachment, in case of a code snippet, email, or file.
  """
  content: String
  """
  The plaintext display name of the attachment
  """
  name: String
  """
  The url of a thumbnail image that might be
  embedded in the attachment, in case of a card
  """
  thumbnailUrl: String
}

input MessageActionPayloadMention {
  """
  The id of the mentioned entity
  """
  id: Int
  """
  The plaintext display name of the mentioned entity.
  """
  mentionText: String
  """
  Provides more details on the mentioned entity.
  """
  mentioned: MessageActionPayloadFrom
}

enum ReactionType {
  like
  heart
  laugh
  surprised
  sad
  angry
}

input MessageActionPayloadReaction {
  """
  The type of reaction given to the message.
  Possible values include: 'like', 'heart', 'laugh', 'surprised',
  'sad', 'angry'
  """
  reactionType: ReactionType
  """
  Timestamp of when the user reacted to the message
  """
  createdDateTime: String
  """
  The user with which the reaction is associated
  """
  user: MessageActionPayloadFrom
}

input MessageActionPayload {
  """
  Unique id of the message
  """
  id: ID
  """
  Id of the parent/root message of the thread
  """
  replyToId: String
  """
  Type of message. Possible values include: 'message'
  """
  messageType: String
  """
  Timestamp of when the message was created.
  """
  createdDateTime: String
  """
  Timestamp of when the message was edited or updated
  """
  lastModifiedDateTime: String
  """
  Indicates whether a message has been soft deleted
  """
  deleted: Boolean
  """
  Subject line of the message
  """
  subject: String
  """
  Summary text of the message that could be used for notifications
  """
  summary: String
  """
  The importance of the message. Possible values include: 'normal', 'high', 'urgent'
  """
  importance: MessageImportanceInGraphFormat
  """
  Locale of the message set by the client
  """
  locale: String
  """
  Sender of the message
  """
  from: MessageActionPayloadFrom
  """
  Plaintext/HTML representation of the content of the message
  """
  body: MessageActionPayloadBody
  """
  How the attachment(s) are displayed in the message.
  """
  attachmentLayout: String
  """
  Attachments in the message - card, image, file, etc.
  """
  attachments: [MessageActionPayloadAttachment]
  """
  List of entities mentioned in the message
  """
  mentions: [MessageActionPayloadMention]
  """
  Reactions for the message.
  """
  reactions: [MessageActionPayloadReaction]
  """
  Deep link to message
  """
  linkToMessage: String
}

type TeamUpdate {
  team: Team!
}

type ChannelUpdate {
  channel: Channel!
}

type CommunitiesUpdate {
  communities: Communities!
}

union CommunitiesUpdateEvent = CommunitiesUpdate

union TeamsAndChannelsUpdateEvent = TeamUpdate | ChannelUpdate
union TeamAndChannelListUpdateEvent = TeamUpdate | ChannelUpdate

###############################################################################
# meeting option types
###############################################################################

input TypedMeetingOptionInput {
  optionList: MeetingOptionListInput
  optionBitMask: MeetingOptionBitMaskInput
  optionBoolean: MeetingOptionBooleanInput
  optionPerson: MeetingOptionPersonInput
  optionSensitivityLabelList: MeetingOptionSensitivityLabelListInput
  optionExternalFeed: MeetingOptionExternalFeedInput
  optionInterpretation: MeetingOptionInterpretationInput
  optionRange: MeetingOptionRangeInput
  optionRadioGroup: MeetingOptionRadioGroupInput
}

enum MeetingOptionsUserType {
  Member
  Guest
  Federated
}

input MeetingOptionsPersonInput {
  upn: String
  objectId: String
  mri: String
  userType: MeetingOptionsUserType
}

input MeetingOptionSensitivityLabelListInput {
  name: String!
  type: OptionValueType!
  currentValue: MeetingOptionSensitivityLabelInput!
  downgradeLabelJustification: String
}

input MeetingOptionSensitivityLabelInput {
  id: String!
  name: String!
}

input MeetingOptionListInput {
  name: String!
  type: OptionValueType!
  currentValue: String!
}

input MeetingOptionBitMaskInput {
  name: String!
  type: OptionValueType!
  currentValue: String!
}

input MeetingOptionBooleanInput {
  name: String!
  type: OptionValueType!
  currentValue: Boolean!
}

input MeetingOptionExternalFeedInput {
  name: String!
  type: OptionExternalFeedType!
  currentValue: Boolean!
  refreshKey: Boolean
  sslEnabled: Boolean
}

input MeetingOptionPersonInput {
  name: String!
  type: OptionPersonType!
  selectedPeople: [MeetingOptionsPersonInput!]!
  maxPeopleSelectionAllowed: Int
}

input MeetingOptionInterpretationInput {
  name: String!
  type: OptionInterpretationType!
  currentValue: Boolean!
  interpreters: [MeetingOptionInterpreterInput!]
}

input MeetingOptionInterpreterInput {
  upn: String
  objectId: String
  mri: String
  tenantId: String
  source: String!
  target: String!
}

input MeetingOptionRangeInput {
  name: String!
  type: OptionValueType!
  currentValue: Int!
  maxAllowedValue: Int!
  minAllowedValue: Int!
}

input MeetingOptionRadioGroupInput {
  name: String!
  type: OptionValueType!
  currentValue: String!
}

enum OptionValueType {
  List
  BitMask
  Boolean
  SensitivityLabelList
  Range
  RadioGroup
}

enum MeetingOptionsCategory {
  Security
  Roles
  Engagement
  RecordAndTranscript
  BroadcastAndStreaming
  AudioAndVideo
}

enum OptionExternalFeedType {
  ExternalFeed
}

enum OptionInterpretationType {
  Interpretation
}

enum OptionPersonType {
  PeopleSelection
  PresenterSelection
}

###############################################################################
# Nova commanding types
###############################################################################

"""
An application specific entity type.

For example, in Teams this could be `activity` or `chat`, whereas in Outlook
this could be `mail` or `calendar`.

The value should be of type string, but clients can choose to provide their own
type mapping to tooling, such as codegen. For instance a TypeScript enum or
string union.
"""
scalar NovaCommandingEntityType
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

"""
An application specific entity action.

For example, in Teams this could be `join` [channel], whereas in Outlook this
could be `send` [email].

The value should be of type string, but clients can choose to provide their own
type mapping to tooling, such as codegen. For instance a TypeScript enum or
string union.
"""
scalar NovaCommandingEntityAction
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

# TODO [#1608105]: These should probably not be scalars, but enums that have shared values across all consumers of Nova
scalar NovaCommandingEntityVisibilityState
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)
scalar NovaCommandingEntityStateTransition
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

# enum NovaCommandingEntityVisibilityState {
#   SHOW
#   HIDE
#   TOGGLE
# }

# enum NovaCommandingEntityStateTransition {
#   NONE
#   FLUSH
#   FORCE_FLUSH
#   NEW
#   EXTEND
# }

type NovaCommandingEntityCommand {
  entity: NovaCommandingEntityInput!
  command: NovaCommandingEntityCommandInput!
}

type NovaCommandingEntityInput {
  """
  This field is historically called `id`, but as it's nullable that would violate the Global Object Idenfitication
  specification. As such we're calling it `entityId` for the time being, as we wait for the whole design of this data
  structure to receive a review/overhaul.
  """
  entityId: String
  type: NovaCommandingEntityType!
  action: NovaCommandingEntityAction!
}

type NovaCommandingEntityCommandInput {
  visibilityState: NovaCommandingEntityVisibilityState!
  stateTransition: NovaCommandingEntityStateTransition!
}

###############################################################################
# Generic image types
###############################################################################

"""
The name of an icon as it exists in the FluentUI library.

Host applications should provide their own type mapping to tooling, such as
codegen that uses the actual string union of allowed icon names supported by
the version of FluentUI that the application ships with. This would typically
be achieved with the following typing:

    keyof typeof import("@msteams/components-fluent-ui-icons")
"""
scalar FluentUIIconName
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

"""
The names of the icons bundled within the AppBar
See data-resolvers-appbar/src/module.graphql
"""
scalar InternalIconName
  @model(tsType: "any", scope: SERVER_RESOLVERS)
  @model(tsType: "any", scope: BROWSER_RESOLVERS)
  @model(tsType: "any", scope: CLIENT_RESOLVERS)

"""
Refers to an icon in the FluentUI library.
"""
type FluentUIIcon {
  """
  The name of the icon as it exists in the FluentUI library.
  """
  name: FluentUIIconName!
}

"""
Refers to a remote image.
"""
type RemoteImage {
  """
  The remote source URI of the image.
  """
  src: String!
  filesize: Int
}

enum PinnedConversationItemType {
  Message
}

input PinnedConversationItemInput {
  itemId: ID!
  itemType: PinnedConversationItemType!
}

union PinnedConversationItemInfo = Message

###############################################################################
# Types for connecting a user's external accounts
###############################################################################
type UserExternalAccount {
  id: String!
  alternateId: String!
  displayName: String
  emailAddress: String!
}

type UserExternalAccountOAuthProviderDetails {
  oAuthProviderType: String
}

type ConnectedCalendarSetting {
  source: ConnectedCalendarSource!
  accountAddress: String!
  accountId: String!
  isSyncAllowed: Boolean!
  eTag: String
}

enum ConnectedCalendarSource {
  Google
}

###############################################################################
# Input for updating webinar unified data
###############################################################################
input WebinarUnifiedDataInput {
  id: ID!
  title: String
  eventType: AppointmentType!
  startTime: String!
  endTime: String!
  eventRecurrencePattern: RecurrencePatternInput
  eventRecurrenceRange: RecurrenceRangeInput
}

type FilesListResult {
  threadId: String!
  files: [FilesListItem!]!
  hasNextPage: Boolean!
  isCachedData: Boolean
}

input P2PFilesInput {
  sortColumn: SortColumn!
  offlineSort: Boolean
  forceRefresh: Boolean
  sortDirection: SortDirection!
}

type FilesListItem {
  sharepointId: String
  driveItemId: String
  fileName: String
  objectUrl: String
  type: String
  modifiedTime: BigInt
  siteInfo: SiteInfo
  shareInfo: ShareInfo
  senderDetails: SenderDetails
  fileLocation: String
}

enum SortColumn {
  TYPE
  TITLE
  MODIFIED
  SENTBY
}

enum SortDirection {
  ASCENDING
  DESCENDING
}

type SiteInfo {
  siteUrl: String
  siteId: String
}

type ShareInfo {
  shareUrl: String
}

type SenderDetails {
  senderName: String
  mri: String
}

type E2eeStatusChangedEvent {
  teamsCallId: ID!
  e2eeEnabled: Boolean!
  fingerPrint: String
  error: String
}

enum RecorderOption {
  OrganizersAndPresentersOnly
  OrganizerAndCoOrganizersOnly
}

enum AutoAdmittedUsersOption {
  Everyone
  EveryoneInSameAndFederatedCompany
  EveryoneInCompany
  EveryoneInCompanyExcludingGuests
  InvitedUsers
  OrganizerOnly
}

enum WhoCanPresentOption {
  Everyone
  EveryoneInCompany
  OrganizerOnly
}

type WatermarkCustomizationSettings {
  opacity: Int
  pattern: WatermarkPattern
}

enum WatermarkPattern {
  Tiled
  Single
}

###############################################################################
# Banner notification intent level
###############################################################################
enum BannerNotificationIntentLevel {
  MostSevere
  Live
  Severe
  Positive
  Neutral
}

enum AttendeeRestrictableModality {
  Audio
  Video
}

type CallParticipantRestrictions {
  participantId: ID!
  restrictions: [AttendeeRestrictableModality!]!
}

enum ChannelCrossPostStatus {
  Success
  Retrying
  SendFailure
  SendFailureCanRetry
  EditFailure
  EditFailureCanRetry
  DeleteSingleFailure
  DeleteSingleFailureCanRetry
  DeleteAllFailure
  DeleteAllFailureCanRetry
}

##########################
# Price and Currency
##########################

type Currency {
  # ISO 4217 code
  code: String!
  name: String
  isDefault: Boolean
  symbol: String
}

type Price {
  amount: String!
  currency: Currency!
}

###############################################################################
# Properties from service, mainly for telemetry purpose
###############################################################################
type CorrelationProperties {
  referenceId: ID!
  traceId: ID!
  logicalId: ID!
}

###############################################################################
# Compose Copilot
###############################################################################

enum ComposeCopilotFeedback {
  Downvote
  Upvote
}

enum ComposeCopilotLoadState {
  Cancelled
  Error
  Initial
  Loading
  Success
}

type ComposeCopilotRequest {
  feedback: ComposeCopilotFeedback
  id: ID!
  input: String
  length: String
  loadState: ComposeCopilotLoadState
  output: String
  tone: String
}

input ComposeCopilotRequestInput {
  feedback: ComposeCopilotFeedback
  id: ID!
  input: String
  length: String
  loadState: ComposeCopilotLoadState
  output: String
  tone: String
}
